## 0. 들어가면서
* 이전까지 동기화(Synchronization) 이슈에 대해 공부했다. 동기화 이슈는 단일프로세서나 멀티프로세서 모두 일어날 수 있는 이슈였는데, User mode, Kernel mode에서 System call의 리소스에 대한 중복 호출이나, Interrupt Handler가 접근하는 리소스가 중복되는 등의 문제로부터 야기됐다.
* 데드락(Deadlock) 문제는 **교착 상태** 문제를 다루는 것인데, Multiple process에서 발생할 수 있다. 동기화 이슈와 약간 비슷한 느낌으로 **사용할 수 있는 자원은 정해져있는데, 이 자원을 사용하고 싶은 다수의 프로세스가 존재할 때** 발생한다. 영어로 정의된 바는 아래와 같다.
```
A set of blocked processes each holding a resource and waiting to acquire a resource held by another process in the set
```
---
## 1. 데드락의 발생 상황
* 아래 간단한 두 가지 예시를 보자.
1) 만약 System이 두 가지의 tape Driver(I/O 장치) P1, P2를 가지고 있다고 하자. 그런데 P1, P2는 각각 하나의 tape drive를 가지고 있으며, 서로 다른 프로세스가 가지고 있는 tape drive가 있어야 종료된다. 이 상황에서는 두 프로세스 P1, P2가 모두 상대방이 끝나고 원하는 자원을 자신아 사용할 수 있어야 종료된다. 하지만, 이미 자신이 하나의 tape drive를 가지고 있게 되면 두 프로세스 모두 종료되지 않고 교착되는 상태에 머무르게 된다.
2) 두 번째 예시는 우리가 Semaphore에 대해 공부했을 때의 예시다. Semaphore 변수 A, B가 존재하는데 프로세스 P1은 A에 대한 wait를 한 뒤 B에 대해 시그널을 보낸다. 마찬가지로 P2는 B에 대한 시그널을 wait한 후에 A에 대한 시그널을 기다린다. 이 상태에서는 양쪽 모두 상대방의 signal을 기다리기 때문에 데드락 문제에 봉착하게 된다.
---
## 2. Resource Allocation Graph
* Graph를 바탕으로 데드락에 대한 상황을 살펴보자. 그래프의 각 Vertex는 Process, Resource를 의미하고 Edge는 Process가 Resource에게 보내는 요청과, Resource가 할당된 정보를 담는다.   
![image](https://user-images.githubusercontent.com/61929745/116031961-c3326900-a699-11eb-9ad9-78f67d33f224.png)

* 위 그래프 예시를 살펴보면 Visualization Process 는 memory frame Resource에 대한 자원을 요청하고, 자신은 Frame Buffer 자원을 할당받고 있다. 하지만 Memory frame Resource는 PostScript Interpeter라는 Process에게 할당되어 있고, 이 Process는 Visualization Process에게 할당된 Frame Buffer resource를 할당받기를 기다린다. 그러면 꼬리에 꼬리를 무는 데드락 상태가 발생하게 된다.
* 한편, 이런 Resource Allocation Graph를 바탕으로 Deadlock이 발생하는 상황을 아래와 같이 정리해볼 수 있다.
```
1) 만약 그래프에 Cycle이 존재하지 않는다면, Deadlock은 발생하지 않는다.
2) Cycle이 있는 그래프는 Deadlock 발생의 필요조건(Necessary condition)이다.
3) 만약 어떤 Resource Type에 오직 하나의 instance밖에 없다면, Cycle이 발생하는 순간 데드락이 발생한다.
```
---
## 3. Necessary Conditions for a Deadlock
* 공룡책을 보면 아래와 같은 4가지 상황이 동시에 발생해야 Deadlock이 발생한다고 본다. 다시 말해서, 이 중에 하나라도 성립이 안되면 데드락은 발생 안할테고 이게 데드락을 방지하는 방법이 될 수 있다는 뜻이다.
```
1. Mutual Exclusion: Resourcec는 하나의 프로세스에만 할당되어야 한다.
2. Hold and Wait: 프로세스는 Resource를 Hold하고 있는 동시에 다른 프로세스가 들고 있는 Resource를 Wait하고 있다.
3. No preemption: Resource는 자신을 Holding하고 있는 process에 의해서만 release될 수 있다.
4. Circular wait: 2번 내용을 포함하고 있는데, 일단 그래프에 Cycle이 있어야 한다는 것이다.
```
* 위 4가지 내용은 직관적으로 이해할 수 있다고 생각한다. 
* 하지만, 이 조건은 **Necessary Condition이지 Sufficient Condition은 아니다!**

---
## 4. 나가면서
* 데드락의 개념과 발생할 수 있는 상황에 대해서 공부했다. 
* 데드락을 방지하고 해결할 수 있는 방법은 데드락을 발생시킬 수 있는 상황과 반대로 만들어주는 것으로 예상할 수 있다.
* 이와 관련된 내용을 다음 글에서 따로 정리하도록 하자.
