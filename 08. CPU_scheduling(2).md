## 0. 들어가면서
* 지난 글에서 CPU scheduling이 필요한 시점에 대해서 공부하고 몇 가지 개념에 대해 배웠다.
* 대표적으로 Preemptive, NonPreemptive 개념에 대해서 배웠고, 스케줄링은 어떤 기준으로 되어야 하는가에 대해 살펴봤다.   
---   
    
    
## 1. FCFS Scheduling
* FCFS Scheduling은 우리가 흔히 알고 있는 First-come First-Served 기반 스케줄링 기법이다.
* Selction Function 관점에서는 Ready Queue에서 가장 오래 기다린(지금 가장 앞에 있는) 프로세스를 선택하고,
* Decision Time 관점에서는 Time Quantum에 대한 고려없이 내 프로세스가 끝나거나 I/O Operation에 의한 block이 일어나지 않는 한 계속되는 Nonpreemptive모드다.
* 하지만 딱 봐도 너무 간단한 스케줄링 기법이라서 몇 가지 문제가 있을 것 같다.
  * 1. 하나의 프로세스가 CPU를 계속 점유할 수 있다 - Time slice가 없는 Nonpreemptive이기 때문에
  * 2. CPU-bound 프로세스는 오래 쓸 수 있으니까 좋은데 I/O bound process는 계속 기다려야 해서 뭔가 불공평하다.
  <img src = "https://user-images.githubusercontent.com/61929745/113649409-56930280-96c9-11eb-8ddc-415e05dd7e64.png" width = 400> 
  
  출처: https://m.blog.naver.com/silro812/221567674463
---

## 2. Round Robin Scheduling
* 라운드 로빈 스케줄링도 FCFS처럼 간단한 스케줄링 기법이다. 
* Selction Function 관점에서는 Ready Queue에서 가장 오래 기다린(지금 가장 앞에 있는) 프로세스를 선택하고,
* Decision Time 관점에서는 **Time quantum을 고려하는 Preemptive**모드다.
* 그런데 이 스케줄링 기법도 문제점이 있는데 잘 생각해보면 아래와 같다.
  * 1. 시간을 공유해야하는 환경에는 적합한데, **너무 빈번하게 Process Switching이 일어나면 오버헤드가 커진다.**
  * 2. 그래서 Time quantum이 너무 크면 FIFO랑 다를게 없어지고, 너무 작으면 오버헤드가 커져서 딜레마가 생기는 것이다.
* 결국 RR 스케줄링은 **Time Quantum을 어떻게 잡느냐**가 중요해지게 되는데, **CPU-bound보다는 좀 크게 , 오버헤드도 상쇄시킬 만큼(?) 크게** 만들어야 한다. 모호하다.
* 또한, **RR 스케줄링 역시 아직까지 CPU-Bound Process에 더 유리할 수밖에 없는데, 왜냐하면 일반적으로 CPU-Bound process가 burst time이 길기 때문에 CPU-bound process가 I/O Operation보다 더 긴 시간동안 time quantum을 쓸 수밖에 없다. 그래서 결국 I/O Bound는 어쨌든 기다리는 시간이 억울하게 많아진다.**
<img src = "https://user-images.githubusercontent.com/61929745/113650393-192f7480-96cb-11eb-8738-cec5fad1a68d.png" width = 400 >   
출처: https://devowen.com/234

* 위 그림과 같이 RR 스케줄링 기법을 적용했을 때 여러 번의 Switching이 일어난다.
* Waiting time을 생각해보면 (57+24)+(20)+(37+40+17)+(57+40) / 4 = 73이다.

---
## 3. SJF Scheduling
* SJF scheduling은 Shortest Job First 스케줄링으로 쉽게 말해서 작업 시간 짧은 녀석부터 해치운다는 것이다.
* Selection function은 **Expected** CPU burst time이다. 아직 작업해보지도 않은 프로세스의 burst time은 알 수 없기 때문에 추정치를 사용한다. 뒤에서 이야기할 예정이다.
* Decision Mode에는 두 가지 있다.
  * **1. Nonpreemptive : 가장 작업시간이 짧은 녀석 선택하면, 그 녀석 끝날 때까지 작업한다.**
  * **2. Preemptive : 가장 작업시간 짧은 녀석을 선택했는데, 작업을 하다가 작업 시간이 더 짧은 다른 녀석이 들어오면 갈아탄다.**
* 이 스케줄링 방식은 위에서 말한 것처럼 **burst time을 어떻게 계산할건데?** 문제에 봉착하는 어려움이 있다. 그리고 상식적으로 CPU burst time이 긴 녀석은 영영 배정을 못받을 수도 있는 문제점이 있다.
* Nonpreemptive, Preemptive SJF Scheduling의 예시를 보자.
![image](https://user-images.githubusercontent.com/61929745/113651195-868fd500-96cc-11eb-9b9e-7a99a44ca24b.png)   
출처: https://cs.stackexchange.com/questions/35723/can-shortest-job-first-scheduling-be-subject-to-convoy-effect
* 그림을 보면 Preemptive SJF의 평균 Waiting time이 적긴한데, 이게 만약에 작업이 엄청 많아지고 교체가 많아진다고 생각해보면 는 매 시간마다 남은 시간이 적은 녀석으로 계속 교체를 할 것이고 그렇게 되면 Switching Overhead가 커질 수도 있다. Waiting time에는 이게 고려되지 않았다는 점을 우선 인식하고 있자.

---
## 4. CPU burst time을 어떻게 측정할까?
* 위의 SJF 스케줄링에서 우리는 **Expected CPU burst time**을 기준으로 남은 예측 작업 시간이 가장 적은 녀석을 선택했다. 그러면 실제로 어떻게 burst time을 추정할까?
