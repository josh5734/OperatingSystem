## 0. 들어가면서
* 지금까지 프로세스 관점에서 스케쥴링에 대해 공부하고 멀티프로세싱, 멀티스레딩, 그리고 각종 동기화 및 데드락 이슈에 대해 공부했다.
* Memory Management는 하나의 물리적인(Physical) 메모리 공간에서 여러 개의 프로세스를 어떻게 돌릴 것인가에 대한 이야기다.
* 메모리 관리(Memory management)를 배우는 목적은 아래와 같다.
```
- 여러개의 프로세스를 하나의 메인 메모리 상에서 어떻게 돌릴 것인가?
- 프로세스마다 점유하고 있는 메모리 간 Protection, Isolation을 어떻게 할 것인가?
- 적은 Overhead를 추구하면서 어떻게 하면 더 메모리 공간을 낭비없이 효율적으로 활용할 것인가?
```
---
## 1. Memory Management Issue
* 구체적으로 메모리 관리 방법에 대해 배우기 전에 메모리 관리가 왜 필요하며 중요한지에 대해 잠깐 짚어보고자 한다.
1. Support for multiple processes: 각각의 프로세스가 점유하는 논리적인(logical) 메모리공간은 연속적(contiguous)이어야 하는데, 메인 메모리 상에 어떻게 이를 올릴 것인가?
2. Enable a process to be larger than the amount of memory allocated to it: 확보된 메모리 공간보다 큰 메모리를 필요로 하는 프로세스를 어떻게 다룰 것인가?
3. Support for multiple regions per process(segments): 프로세스의 메모리 공간(data, stack, heap...)에서 서로 다른 특징을 갖는 메모리 공간을 어떻게 다룰 것인가?
4. Protection & Sharing: 한 프로세스가 점유하고 있는 메모리를 다른 프로세스가 사용하지 못하게 하거나 혹은 여러 프로세스가 같은 메모리를 공유할 때 어떻게 해야 할 것인가?
5. Performance: 메모리 공간을 load, release할 때 드는 overhead를 어떻게 줄이고, 메모리 공간을 어떻게 하면 낭비없이 잘 쓸 수 있는가?

---

## 2. Address Spaces
* 메모리 관리에 대해 본격적으로 들어가기 전에 기본적인 주소 공간에 대한 개념을 이해해야 할 것 같다.
* 주소 공간은 크게 두 가지로 분류된다.
1. Physical address space: 물리적 주소 공간은 하드웨어에 실제로 존재하는 주소를 의미하고, 메인 메모리가 512MB의 용량이라고 할 때 그 용량 자체를 의미하는 것이다.
2. Logical address space: 논리적 주소 공간은 **프로세스 관점**에서 자신이 가지고 있는 메모리 크기를 의미한다. 

* 우리가 지금 다루고자 하는 메모리 관리는 기본적으로 Logical address space에 대한 것이다. 
* 그리고 주소 공간에 대해 기본적인 질문 두 가지를 짚어보고자 한다.
Q. 예전에 32bit architecture를 공부하면서 내 프로세스는 0~4GB의 PCB address를 가진다고 했는데, physical memory가 512MB이면 어떻게 더 작은 메모리 공간에 더 큰 프로세스를 올리는 것일까?
A. 다음 장에서 배우는 가상 메모리의 개념에서 더 자세하게 배울 것이고, 사실은 Logical address를 OS가 physical memory address에 매칭해주는 것이다.

Q. CPU가 $PC, $SP 등을 쓰는데 PC가 가지는 주소는 물리주소일까? 논리주소일까?
A. PC는 논리주소를 나타낸다.
---

## 3. Hardware for Address Translation
---

## 4. Swapping

---

* 이제 본격적으로 메모리 관리를 어떻게 하는가에 대해 기본적인 방법 몇가지를 공부해보고자 한다.
* 이 방법들에 대해서는 다음 글에 새로 정리하려고 한다.
