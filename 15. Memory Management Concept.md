## 0. 들어가면서
* 지금까지 프로세스 관점에서 스케쥴링에 대해 공부하고 멀티프로세싱, 멀티스레딩, 그리고 각종 동기화 및 데드락 이슈에 대해 공부했다.
* Memory Management는 하나의 물리적인(Physical) 메모리 공간에서 여러 개의 프로세스를 어떻게 돌릴 것인가에 대한 이야기다.
* 메모리 관리(Memory management)를 배우는 목적은 아래와 같다.
```
- 여러개의 프로세스를 하나의 메인 메모리 상에서 어떻게 돌릴 것인가?
- 프로세스마다 점유하고 있는 메모리 간 Protection, Isolation을 어떻게 할 것인가?
- 적은 Overhead를 추구하면서 어떻게 하면 더 메모리 공간을 낭비없이 효율적으로 활용할 것인가?
```
---
## 1. Memory Management Issue
* 구체적으로 메모리 관리 방법에 대해 배우기 전에 메모리 관리가 왜 필요하며 중요한지에 대해 잠깐 짚어보고자 한다.
1. Support for multiple processes: 각각의 프로세스가 점유하는 논리적인(logical) 메모리공간은 연속적(contiguous)이어야 하는데, 메인 메모리 상에 어떻게 이를 올릴 것인가?
2. Enable a process to be larger than the amount of memory allocated to it: 확보된 메모리 공간보다 큰 메모리를 필요로 하는 프로세스를 어떻게 다룰 것인가?
3. Support for multiple regions per process(segments): 프로세스의 메모리 공간(data, stack, heap...)에서 서로 다른 특징을 갖는 메모리 공간을 어떻게 다룰 것인가?
4. Protection & Sharing: 한 프로세스가 점유하고 있는 메모리를 다른 프로세스가 사용하지 못하게 하거나 혹은 여러 프로세스가 같은 메모리를 공유할 때 어떻게 해야 할 것인가?
5. Performance: 메모리 공간을 load, release할 때 드는 overhead를 어떻게 줄이고, 메모리 공간을 어떻게 하면 낭비없이 잘 쓸 수 있는가?

---

## 2. Address Spaces
* 메모리 관리에 대해 본격적으로 들어가기 전에 기본적인 주소 공간에 대한 개념을 이해해야 할 것 같다.
* 주소 공간은 크게 두 가지로 분류된다.
1. Physical address space: 물리적 주소 공간은 하드웨어에 실제로 존재하는 주소를 의미하고, 메인 메모리가 512MB의 용량이라고 할 때 그 용량 자체를 의미하는 것이다.
2. Logical address space: 논리적 주소 공간은 **프로세스 관점**에서 자신이 가지고 있는 메모리 크기를 의미한다. 

* Logical Address와 Physical가 생성되는 시점과 Physical Address에 매핑되는 시점은 아래 그림과 같다.   
![image](https://user-images.githubusercontent.com/61929745/120959985-ecb0db00-c795-11eb-903b-26a7c4cde073.png)


* Compilation, Assembling 과정이 끝나면 object 파일이 만들어지고, 이 때 0~75의 Logical address가 부여된다. 이후에 Linking 과정이 일어나면 프로그램을 실행하기 위한 코드 조각들을 불러온다. 예를 들어 printf()함수를 호출하기 위해서는 실제 printf() 함수가 어느 라이브러리에 있고, 그 라이브러리를 찾아서 엮어줘야 하는 것이다.
* 마지막으로 프로그램이 실제로 load 되면, Physical address에 할당된다. 그림에서 볼 수 있는 것처럼 각 주소 공간은 하위 메모리부터 채워져 나간다.

* 한편, 주소 공간에 대해 기본적인 질문 두 가지를 짚어보고자 한다.
```
Q. 예전에 32bit architecture를 공부하면서 내 프로세스는 0~4GB의 PCB address를 가진다고 했는데, physical memory가 512MB이면 어떻게 더 작은 메모리 공간에 더 큰 프로세스를 올리는 것일까?
A. 다음 장에서 배우는 가상 메모리의 개념에서 더 자세하게 배울 것이고, 사실은 Logical address를 OS가 physical memory address에 매칭해주는 것이다.

Q. CPU가 $PC, $SP 등을 쓰는데 PC가 가지는 주소는 물리주소일까? 논리주소일까?
A. PC는 논리주소를 나타낸다.
```
---

## 3. Hardware for Address Translation
* 위에서 말한 것처럼, 프로세스의 논리적 주소는 하드웨어에 의해 물리적인 주소 공간으로 변환된다.
* 즉, 프로그램은 execution time에 동적으로 **relocated**되는 것이다.
* 이 때, 프로그램은 'Relocation register + Limit register'로 계산하여 물리적 주소 공간을 확보하게 된다. 아래 그림을 참고하면 좋겠다.

![image](https://user-images.githubusercontent.com/61929745/116895567-4d686780-ac6e-11eb-94e4-32c1ff92e15d.png)

---

## 4. Swapping
* Swapping은 메모리 관리를 하는 데 있어서 굉장히 기본적이고 중요한 개념이다.
* Swapping의 정의에 대해 우선 확인해보자.
```
- Swapping : A process can be Swapped temporarily out of memory to a backing store, 
              and then brought back into memory for continued execution.
```
* Swapping은 쉽게 말해서 한정된 물리적 메모리 공간 안에 여러 프로세스 메모리를 올리기 위해서 임시로 자리를 비우고, 채우고 하는 행위를 반복하는 것이다.
* 일반적으로 Non-volatile Memory(HDD 등)는 메인 메모리(RAM 등)보다 큰 메모리 공간을 가지고 있다.
* 따라서 메인 메모리에 특정한 프로세스를 올려야 하는데 **공간이 없으면 이미 올려져 있는 어떤 프로세스를 잠시 다른 HDD 등에 옮겨두고 작업을 한 뒤, 다시 옮겨둔 프로세스를 불러와서 작업을 재개하는 것**이다. 이 때, Swapping을 위해 필요한 공간을 **Backing store**라고 한다.
* Swapping에 대한 개념 역시 아래 그림을 통해 이해하면 쉬울 것 같다.   
![image](https://user-images.githubusercontent.com/61929745/116896311-1777b300-ac6f-11eb-9b75-7d8ef8eabbb8.png)

* Swapping에 있어서 소요되는 거의 모든 시간은 transfer time인데, 메모리 자체를 옮기는 작업이기 때문에 이 시간 역시 메모리 크기에 비례하게 되고 메모리가 크면 꽤나 큰 오버헤드가 생길 수 있다. 또한 기본적으로 Backing store는 HDD을 쓰기 때문에 RAM처럼 Access 속도가 빠르지 않다는 점에서 오버헤드가 생길 수밖에 없다.
* 아래 Transfer time에 대한 예시를 보자.   
![image](https://user-images.githubusercontent.com/61929745/120960314-86788800-c796-11eb-90c1-d70d0a206b3a.png)

출처: https://www.javatpoint.com/swapping-in-operating-system



---
## 5. 마치면서
* 이제 본격적으로 메모리 관리를 어떻게 하는가에 대해 기본적인 방법 몇가지를 공부해보고자 한다.
* 이 방법들에 대해서는 다음 글에서 새로 정리하자.
