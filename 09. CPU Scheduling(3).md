
# CPU Scheduling(3)
* 지난 시간에 SJF Scheduling에 대해 공부했다. 
* SJF Scheduling은 Expected burst time이 가장 작은 작업에 우선순위를 높게 할당하는 방식으로 스케줄링을 했다.
* 오늘 글에서는 그렇다면 어떻게 burst time을 Expectation하는가에 대해서 이야기하는 것으로 시작하려고 한다.


## 1. Estimating CPU burst time
* CPU burst time을 측정을 위해 과거에 이 프로세스가 CPU를 사용했던 시간 기록을 이용한다. 
* CPU burst time을 측정하는 크게 두 가지 방법이 있다.   
```
1. Simple Average : 이 프로세스의 과거 CPU 사용 시간들에 대해 동일한 Weight를 주는 방식으로 평균값을 구한다.
2. Exponential Average : 최근에 거쳤던 작업시간이 현재 작업 시간을 결정하는데 큰 영향을 미치리라는 가능성으로 가까운 시간에 대해 더 큰 Weight를 주는 방식으로 평균값을 구한다.
```
* 아래는 Simple averaging과 Exponential averaging을 이용했을 때 실제 burst time과 비교한 그래프다.
<img src = "https://user-images.githubusercontent.com/61929745/114254643-886ad880-99eb-11eb-84c8-79fbb1f9bde0.png" width =400 height = 400>   
* Exponential averaging 방법이 실제 시간과 조금 더 근접하게 맞춘다는 것을 볼 수 있다. 하지만 기억해야 할 점은 Exponential Averaging이 모든 burst time을 예측하는데 가장 좋은 방법이라고 할 수도 없고, 실제로는 더 복잡한 과정을 통해 예측이 이루어진다.
---

## 2. 멀티레벨 큐(Multi-lelevel Queue Scheduling)
* OS가 복잡해지면서 Scheduling을 하는 방식도 상당히 복잡해졌다. 이에 따라 하나의 Ready Queue만 가지고 어떻게 그 많은 프로세스들을 관리하기가 어려워졌다.
* 따라서 다양한 유형의 프로세스들을 관리하기 위해서는 여러 개의 큐를 가지고(Multi-level queue) 각자 다른 알고리즘으로 스케줄링을 설계해야 한다.

### 멀티레벨 피드백 큐(Multilevel Feedback Queue Schedulig(MLFQ))
* **Multilevel Feedback Queue Scheduling은 한 프로세스가 여러 단계의 큐를 지나서 수행되는 것**을 의미한다.
<img src = "https://user-images.githubusercontent.com/61929745/114254968-7ab65280-99ed-11eb-8d8f-9c3cdd7c510a.png" width = 500 height = 400>    
* 출처: https://jhnyang.tistory.com/156   
 
* 가장 상위에 존재하는 큐가 우선순위가 높게 설정되어 가장 아래에 있는 큐는 위쪽의 큐가 모두 비어있는 상태가 되어야 사용이 가능해진다.
* MLFQ에서는 첫번째 큐의 Time slice를 작게 해서 I/O bound process인 경우 대부분이 첫 큐에서 끝나고 나가게 하고, CPU bound process의 경우 아래로 내려가게 만든다. 그리고 아래로 내려갈수록 Time slice를 조금 더 길게 주는 방식을 채택한다. 여기서 각 Queue마다 Time slice가 있다는 것은 MLFQ가 Preemptive Schedulig방식을 취한다는 것을 의미한다.
---

## 3. Fair Share Scheduling(FSS)
* Multiuser System에서 각 유저는 각자의 여러 Process를 갖고 있다.
* FSS의 개념은 그룹에 속한 유저들에 대해서 공평하게 CPU할당량을 제공해야 한다는 것이다.

---
## 4. 실시간 시스템 스케줄링(Real-Time Scheduling)
* 실시간 시스템 스케줄링의 개념은 제조 산업, 공정, 방위 산업 등에서 중요하다.
* 실시간 시스템 스케줄링의 개념은 쉽게 생각해서 **이 프로세스를 주어진 시간 안에 끝내라**라는 내용이다. 
* 하지만 이 스케줄링 기법에도 두 가지 갈래가 존재한다.
    * (1) Hard Read-Time Scheduling: 데드라인을 못 맞추면 의미가 없어지는 스케줄링이다. 이를 위해서는 각 프로세스가 그들이 필요한 사용량을 제공해야 하고, 최악의 경우에 어느 정도 시간이 소요되는 지 등도 염두해야 한다.
    * (2) Soft Real-Time Scheduling: 데드라인을 못맞춰도 프로그램이 흘러가기는 한다. 따라서 엄연히 말해서는 약간 실시간 시스템의 의미가 퇴색되기는 한다. 이 스케줄링 기법에서는 중요한 프로세스에게 더 높은 우선순위를 주고, 우선순위 스케줄링을 돌리게 된다. 또한 Dispatch latency(Switching delay)를 줄이기 위해 커널은 Preemptive하게 만든다고 하는데, 이 부분에 대해서는 아직 깊게 이해하지 않아도 될 것 같다.

* 생각해보면 실시간 시스템 스케줄링은 급한 녀석을 빨리 처리하게 해줌으로써 프로그램이 돌아가는 데 좋은 영향을 미칠 것 같다. 하지만 아래의 문제점에 대해서 생각해보자.
### Priority Inversion Problem(우선순위 역전 문제)
<img src = "https://user-images.githubusercontent.com/61929745/114255662-9f132e80-99ef-11eb-8f9f-9b95c5c85c66.png" width = 500 height = 400>     

* 위 그림과 설명에 대해서 이해해보면 우선순위가 역전된다는 문제가 무엇인지 바로 이해할 수 있다.
    * (1) 높은 우선순위를 가진 프로세스나 스레드(P1)가 존재한다.
    * (2) 처음에 우선 순위가 낮은 프로세스(P3)가 작업을 실행하고 Global memory에 대해 Lock을 걸었다.
    * (3) 그런데 Time quantum이 끝나서 lock을 해놓은 상태로 더 높은 우선순위를 가진 프로세스에게(P3) 작업권이 넘어갔다.
    * (4) 가장 위에 존재하는 프로세스(P3)는 똑같은 Global memory를 사용하려고 했는데, 낮은 우선순위의 프로세스(P1)가 blocking 중이어서 사용하지 못한다.
    * (5) 위의 프로세스가 작업을 안하니까 그 아래 우선순위를 가진(P2)가 CPU를 사용하게 된다.

* 이 문제를 해결하기 위한 방법은 아래와 같다.
    * (1) 순간적으로 문제를 제공했던 P3에 대해서 P1이 자신의 우선순위를 상속해준다. 
    * (2) 그러면 낮은 레벨에 있던 프로세스가 얼른 작업을 끝내고 다시 높은 우선순위의 프로세스가 작업을 할 수 있도록 해준다.

---
### 5. 옛 Linux 2.6의 Scheduling은 어떻게?
* Linux 2.6의 Scheduling 방식의 특징에 대해서 공부해보자.
    * (1) **Priority based, Time-sharing, Preemptive Scheduling**방식을 채택한다.
    * (2) POSIX.4 compatible하다. POSIX는 IEEE가 정한 운영체제 인터페이스 규격인데, POSIX에서 정한 Scheduling 규칙을 준수하면서 만들어졌다는 뜻이다. 구체적으로 **SCHED_FIFO, SCHED_RR을 필수적으로 구현하고 나머지(SCHED_OTHER)에 대해서는 각 운영체제에 맞게 구현하라는 것이다.** 아래 그림을 같이 보자.   
    <img src = "https://user-images.githubusercontent.com/61929745/114256276-35951f00-99f3-11eb-8566-a8e03486f970.png" width = 600, height= 200>   

    * (3) **SCHED_FIFO**는 정해진 우선순위 구간에 있는 녀석들에 대해서는 Time limit 없이 작업을 수행하라는 Hard real-time 성격을 지닌 스케줄링 기법이다. **다만 이 녀석들은 더 높은 우선순위에 있는 작업이나 I/O Block에 대해서만 Preemptive하다.**
    * (4) **SCHED_RR**은 대신에 우선순위 구간에 있는 녀석들도 Time quantum이 존재하면서 스케줄링하는 방식이다. 그니까 앞에서 배운 Soft real time Scheduling 느낌으로 이해하면 된다.
    * (5) **그러니까 LINUX는 총 140개의 우선순위 레벨을 정해놓고 프로세스를 관리하는데, 상위 100개의 우선순위에 대해서는 SCHED_FIFO, SCHED_RR 방식으로 스케줄링을 하라는 것이고 하위 40개의 우선순위에 대해서는 알아서 하라는 뜻이다.** 
    * (6) **SCHED_OTHER**는 시스템에서 실행중인 다른 작업에 따라 특정 타임 슬라이스에 대한 작업을 예약하는 일반적인 RR 스케줄링 방식을 사용한다. 
---

### 6. 마치면서
* 지금까지 CPU Scheduling의 필요성, 기본적인 스케줄링의 방법과 장단점, Burst time Expectation 등에 배웠다.
* 또한 멀티레벨큐 중 멀티레벨 피드백 큐(MLFQ)와 실시간 시스템 스케줄링 기법, 리눅스 운영체제의 스케줄링 기법에 대해 공부했다.
* 사실 스케줄링 기법은 워낙 방법론이 많고 각 운영체제마다, 사용자마다 다르게 사용되며 지금도 연구되고 있기 때문에 모든 것을 다 이해할 수는 없다. 하지만 지금까지 배운 내용을 토대로 왜 스케줄링이 필요하며 각 스케줄링 기법이 어떤 장점이 있고 문제가 있는지를 이해하면 될 것 같다.
