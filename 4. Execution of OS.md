### 1. Execution of the Operating System - 운영체제는 어떻게 동작하는가?
* 우리는 지금까지 운영체제에 대해 이것저것 이야기를 했다. 그렇다면 정작 운영체제 이 자체는 어떻게 동작할까? 흥미롭게도 **운영체제 역시 프로세서에 의해 실행되는 하나의 프로그램**이다.
* 그렇다면 OS가 다른 프로그램처럼 프로세서에 의해 실행되는 것이라면 두 가지 의문이 생길 수 있다.
  * 1. **운영체제는 프로세스(Process)** 인가?
  * 2. 운영체제 자체를 어떻게 구현할 것인가?
* 이 질문에 대답하기 위해 운영체제를 디자인하는 두 가지 방법이 고안되었다.


### 2. Execution within User Process
* 첫 번째 방법은 User Process 안에서 OS가 동작하는 것이다.    
![image](https://user-images.githubusercontent.com/61929745/112716251-91a67080-8f28-11eb-929d-d5e610fd1ad0.png)    
출처: https://happy-chipmunk.tistory.com/17
* 커널(운영체제)은 User process의 일부분처럼 나타난다. 다시 말해서, OS Code가 앞에서 살펴본 프로그램 이미지(Image)와 연결되어 있다는 것이다. 한편 이 방법에서 Interrupt가 일어나게 되면 CPU는 User mode에서 Kernel mode로 Mode-Switching을 하게 되는데, **이 때, OS가 각 User process 위에 있기 때문에 Process 간 Switching이 일어날 필요가 없게 되고, 이는 곧 같은 프로세스 안에서의 mode switching만 일어나게 해서 Overhead를 감소시켜준다.**  
* 우리가 잘 알고 있는 Linux가 Execution within User process 모델을 가지고 있다. 구체적인 Linux Process Image를 보면 아래와 같고, 몇 가지 설명을 수업시간에 써넣었다.   
<img src = "https://user-images.githubusercontent.com/61929745/112716417-b7804500-8f29-11eb-9338-6771fe113cc6.png" height = 600>    
* 위의 그림에서 Kernel의 주소 공간은 User 주소 공간의 바로 위에 1GB 크기로 자리 잡고 있다. 그리고 이 윗부분의 주소 공간을 모든 Process에서 공유(dead copy)하고 있게 된다. 커널이 별도의 PCB로 존재하지 않기 때문에 Mode Switching만 필요하게 되고, 따라서 Overhead가 적게 된다. 

### 3. Process-based Operating System
* 두 번째 방식은 각 User Process와는 독립적으로 OS Process가 PCB로 존재하는 것이다.   
![image](https://user-images.githubusercontent.com/61929745/112716609-a8e65d80-8f2a-11eb-939b-b546a0919ea6.png)
* 여기에서는 칵 Kernel을 독립된 process로 구성하게 되고, OS를 이러한 Process들의 집합으로 보는 것이다. 앞선 방식에서는 커널이 각 유저 프로세스마다 존재했고, 그 공간이 1GB정도였는데, 여기서는 각 커널이 하나의 프로세스 전체를 차지하게 되므로 4GB 전체를 쓸 수 있게 되었따. 또한 OS를 모듈로 나눠서 구현 가능하게 되고, 병렬 컴퓨터라면 높은 스피드를 낼 수 있게 된다.
* **하지만 무엇보다 큰 단점은 각 OS가 독립적인 프로세스로 존재하기 때문에, Mode Switching이 아니라 Process Switching이 필욯게 되고, 이에 따라 속도가 느려진다.**



### 4. System calls for Processes
* Mode Switching을 유도하는 데는 System call이 있다고 계속 말해왔다. 그렇다면 System call에는 무엇이 있을까?
  * **1. fork()**: 새로운 프로세스를 생성하고, Calling process를 복제한다. 구체적으로 여기서 복제되는 Process를 Child, fork()를 수행하는 Process를 Parent라고 한다. fork()를 수행하게 되면 기본적으로 **pid를 제외한 모든 내용이 identical**하다. 또한, fork() 명령어 수행 시 Parent는 Child의 pid값을 return하고, child는 0을 return한다. 그래서 이 return값을 기준으로 parent, child가 다른 동작을 수행할 수 있게 되는 것이다. 맨 처음 main()에서 fork()를 수행해서 pid = fork()라는 줄이 있었다고 하면, 그 다음 순간 parent, child process가 존재하게 되고, 각 내용은 지금 당장은 identical하기 때문에 if(pid ==0) / else ~ 로 각 프로세스가 하는 동작을 구분할 수 있는 것이다. 아래 그림을 보면 이해하기 쉬울 것 같다.   
  ![image](https://user-images.githubusercontent.com/61929745/112716913-88b79e00-8f2c-11eb-99da-d2958bba62e0.png)   
  출처: https://www.csl.mtu.edu/cs4411.ck/www/NOTES/process/fork/create.html
---
  * **2. exec()**: fork() 수행 시 복제한 내용을 새로운 프로세스 내용으로 갈아치운다. 쉽게 말해서, fork()와 쌍으로 같이 다니는 명령어일 수 있는데, fork() + exec()를 수행하게 되면, 새로운 프로세스를 만들고 그리고 그 프로그램 안에다가 새로운 내용물을 넣는다는 것이다. exec()를 수행한다고 해서 다른 pid를 갖는 process가 되는 것은 아니고, 그 내용물만 바뀐다.   
   <img src = "https://user-images.githubusercontent.com/61929745/112717000-2f03a380-8f2d-11eb-9b39-6f053b7e95a8.png" width = 600>   
  * 출처: https://web.stanford.edu/~ouster/cgi-bin/cs140-spring20/slides/thread.pdf   

* 추가적으로 exex 계열의 시스템 콜 함수에 대해서 알아보면 아래와 같다.   
```c
int execl(const char *path, const char *argo0, ..., const char *argn, (char *)0);
/* 
* path에 지정한 경로명의 파일을 실행하며 arg0~argn을 인자로 전달한다.
* arg0에는 실행 파일명을 저장하고, 마지막 인자에는 인자의 끝을 의미하는 NULL 포인터를 지정해야 한다.
*/

int execv(const char *path, char *const argv[]);
/*
* path에 지정한 경로명에 있는 파일을 실행하여 argv를 인자로 전달한다. 
* argv는 포인터 배열이다. 이 배열의 마지막에는 NULL문자열을 저장해야 한다.
*/

int execle(const char *path, const char *argo0, ..., const char *argn, (char *)0, *const envp[]);
/*
* path에 지정한 경로명의 파일을 실행하여 arg0~argn과 envp를 인자로 전달한다. 
* arg0~argn을 포인터로 지정하므로, 마지막 값은 NULL 포인터로 지정해야 한다.
* envp는 포인터 배열이기 때문에 마지막에 NULL 문자열을 저장해야 한다.
*/

int execve(const char *path, char *const argv[], char *const envp[]);
/*
* path에 지정한 경로명의 파일을 실행하여 argv, envp를 인자로 전달한다.
* argv와 envp는 포인터 배열이다. 이 배열의 마지막에는 NULL문자열을 저장해야 한다.
*/

int execlp(const char *file, const char *arg0,..., const char *argn, (char *)0);
/*
* file에 지정한 파일을 실행하여 arg0~argn만 인자로 전달한다. 파일은 이 함수를 호출한 프로세스와 검색 경로에서 찾는다. 
* arg0~argn은 포인터로 지정하고, execl 함수의 마지막 인자는 NULL 포인터로 지정한다.
*/

int execvp(const char *file, char *const argv[]);
/*
* file에 지정한 파일을 실행하여 argv를 인자로 전달한다. argv는 포인터 배열이다.
* 이 배열의 마지막에는 NULL 문자열을 저장해야 한다.
*/
```


---
  * **3. wait()**: Child Process가 종료될 때까지 기다려주는 역할을 하고, 기본적인 프로세스 간 Synchronization을 도와준다. wait() function을 통해서 Block을 하거나, Child가 수행한 상태의 결과값을 바로 return하는 상황 등에서 필요하다. 
---
  * **4. exit()**: 프로세스를 종료한다.


### 4. IPC(Interprocess Communication)
* 위에서 프로세스 간 Swtiching에 대해서도 알아보았고, exec(), wait()함수 등을 통해 자식, 부모 프로세스 간 간단한 system call에 대해서도 알아보았다. 그렇다면 궁극적으로 Process마다 communication하고 synchronize하기 위해서는 어떤게 필요할까? 이에 대한 물음의 답이 IPC라고 할 수 있다.
* IPC의 기본 아이디어는 다음과 같다 - **막강한 서버에 작업을 두고 클라이언트는 이거를 갖다가 쓰면 어떨까?**
* 과거에는 Pipe라는 개념을 통해 연관성이 있는 두 프로세스 간 통신을 했고, 한 발 나아가 named pipe 혹은 FIFO라고 불리는 개념을 통해 연관성이 없는 두 프로세스의 통신을 할 수 있었다. 
* 하지만 최근에는 **SOCKET** 을 활용하기 시작했다. 소켓은 컴퓨터네트워크 시간에 자세히 배운 개념이다. 각 프로세스는, 유저 내 프로세스 뿐만 아니라, 유저 간 프로세스 역시 양방향 소켓을 통해서 메시지를 주고 받을 수 있게 되었다. 그리고 이 소켓은 크게 TCP 혹은 UDP 전송 프로토콜을 사용하는데 간단한 특징은 아래와 같다.
  * TCP: 연결지향성, 신뢰적인 전송, 순서 보장O, 양방향성
  * UDP: 비연결, 비신뢰전송, 순서 보장X, Can send or receive
* 사실 TCP, UDP에 대해서는 좀 더 많은 내용을 네트워크 시간에 배웠기 때문에 여기서 다시 정리하는 것은 너무 길어질 것 같다. **결론적으로 중요한 것은, SOCKET 통신을 통해서 우리는 이제 Process가 어디에 있든 서로 통신하고 동기화할 수 있는 장치가 마련되었다는 것이다.**

### 5. Multithreading
* 소켓을 통해 프로세스 간 통신과 동기화는 해결할 수 있다고 배웠는데... IPC가 거대한 서버에서 클라이언트의 작업을 처리하는 개념이라고 했고, 그러면 TCP 통신을 통해서 서버와 클라이언트간 프로세스 통신이 있을 수 있겠다. **그런데 서버 용량이 너무 커져서 감당을 할 수 없게 되면?** - Multithreading에 대한 이야기를 다음에 하게 될 것이다.
