## 0. 들어가면서
* 지금까지 배운 Partitioning, Buddy system 등의 메모리 관리 기법은 프로세스의 논리적인 메모리 주소를 물리적인 메인 메모리에 **연속적인 Mapping**을 전제했다.
* 하지만 지금부터 알아 볼 Paging에서는 물리적인 주소가 연속적이지 않은 상황에서도 가능하다.

---
## 1. Paging Concepts
```
1. frames: Physical memory를 fixed-size로 분할한 블록
2. pages: Logical memory를 fixed-size로 분할한 블록

- frame과 page의 size는 같게 설정하도록 한다.
- To run a program of size 'n' pages, we need to fine 'n' free frames and load program
```
* 위에 설명한 것처럼 Paging 기법은 프로세스의 논리적 메모리와 메인 메모리의 주소를 일정한 크기로 쪼개서 각각을 매칭하는 것으로 이해하면 된다.
* 당연하게도 메모리를 일정한 크기로 쪼개서 각각을 매칭하는 것이기 때문에 Internal framentaion이 존재할 수 있다.
---

## 2. pages, frames
1. page의 개념
* 프로세스의 논리적 주소 공간은 여러 개의 동일한 크기의 page들로 쪼개진다.
* 따라서 논리적 주소의 한 부분은 (# of page, offset)으로 표현이 가능하다.
2. frame의 개념
* 마찬가지로 물리적 주소 공간 역시 여러 개의 동일한 크기의 frame들로 쪼개진다.
* 따라서 물리적 주소이 한 부분 역시 (# of frame, offset)으로 표현이 가능하다.

```
- 논리적 메모리와 물리적 메모리가 각각 page, frame으로 쪼개졌고
- 이제 우리는 아래 그림처럼 pages를 frames로 Mapping이 가능해진다.
```
![image](https://user-images.githubusercontent.com/61929745/117564825-ee30aa00-b0e8-11eb-9a29-4192d3e92d45.png)   

---

## 3. Virtual Address Translation
* page는 논리적 주소 공간을 쪼갠 것이고, frame은 물리적 메모리 공간을 쪼갠 것이다.
* 위의 그림처럼 page는 frame에 각각 매핑이 되고, 반드시 연속적으로 매핑될 필요는 없다.
* 그러면 어떻게 page들을 frame에 매핑할까?
```
- 기본적으로 모든 page는 각자가 매핑되는 frame에 대한 정보가 기록된 Page Table이 필요하다.
- 따라서 Page table은 페이지의 수만큼의 entry를 가져야한다.
```

- 이제 Mapping 과정을 조금 더 구체화시켜보자.
1) 위에서 논리적 메모리 주소는 (# of page, offset)으로 표현된다고 했고, page의 크기와 frame의 크기는 같다고 했다.
2) 만약 시스템이 32KB의 물리적 주소 공간을 갖고, 각 페이지는 1024byte의 공간을 갖는다고 해보자.
3) 그러면 하나의 페이지 내에서 가질 수 있는 offset의 주소는 0부터 1023이 되고, frame 역시 같은 사이즈니까 0부터 1023만큼의 offset이 존재하겠지?
4) 그래서 virtual address의 bit를 하위 10개를 offset(0~1023)을 표시하도록 사용하고, 물리 주소 공간이 32KB = 2^15칸이니까 총 페이지는 5개가 되니까 그 다음 5bit를 매핑할 프레임 인덱스로 쓰면 된다.
5) 아래 그림처럼 4번째 page의 offset = 0인 블록은 0번째 frame의 offset = 0에 매핑이 되고, 3번째 page의 offset = 1023인 블록은 4번째 frame의 offset = 1023에 매핑된다.   
![image](https://user-images.githubusercontent.com/61929745/117565189-e40fab00-b0ea-11eb-80b8-66bd8fb97da2.png)

6) 사실 그림의 page table을 자세히 들여다보면, 몇 번째 page가 몇 번째 frame으로 매핑되어 있느냐가 써있기는 한데, offset 정보는 안 써있다.
7) TODO: offset 정보는(?)  --> 교수님께 여쭤보니 offset 정보는 그대로 copy된다고 한다. Paging의 중요한 개념은 **각 page가 frame에 어떻게 대응되느냐가 중요한 것**이라고 하셨다.
---

## 4. Page Table Structure
* 프로세스 하나는 하나의 Page table을 가지고 있고, 테이블 안에는 프로세스의 모든 Page To frame Mapping 정보가 담겨있다.
* 하지만 Page table은 단순히 이 정보만 담고 있는 것이 아니고, **Bit flags** 정보를 담고 있다.
* Bit flag에는 present bit, dirty bit, reference bit, protection bit 등이 존재한다.
* 예를 들어 Dirty bit는 해당 페이지가 수정된 적 있느냐, Accessed bit은 해당 페이지가 reference 된적 있느냐, Page present bit은 page 자체가 생성되어 있느냐 등의 정보를 담는다.   
![image](https://user-images.githubusercontent.com/61929745/117565437-31d8e300-b0ec-11eb-963b-9bd6f530731c.png)

* dirty bit, present bit, reference bit은 페이지 교체 정책에서 어떤 페이지를 evict할 것인가? 물리 메모리에서 사용 중인가?를 판단할 때 사용되기 때문에 중요하다.
---

## 5. Page Sharing
* 여러 프로세스의 Page들은 똑같은 하나의 frame에 Mapping될 수 있다.
* 생각해보면 여러 프로세스마다 동일한 데이터를 쓰는데 굳이 다른 frame을 계속 할당할 필요가 없는 것이다.

---

## 6. Page Table Implementation Issue
* 이제 실제로 Page table을 구현 이슈에 대한 논의를 하려고 한다.
* 지금까지 내용을 간단히 요약하면 Page table은 각 프로세스마다 존재하고, 프로세스가 가지고 있는 Page 수만큼의 entry를 가진다. 그리고 각 entry는 mapping되는 frame에 대한 정보와 flag bit를 갖고 있다.

* 우선 Page table 구현을 위해 필요한 두 가지 개념에 대해 일단 알아보자.
```
1. Page-table base Register(PTBR): Points to the page table
2. Page-table length Register(PTLR): indicates size of the page table
```

### 1) Memory Access Overhead 
* 우리는 Physical memory에 저장된 정보를 읽기 위해 두 번의 Memory Access를 필요로 한다.
```
1) Page Table에 Access하여 Mapping 된 frame의 정보 얻기
2) 실제 Memory에 접근해서 data/instruction 읽기
```
* 위와 같은 과정에서는 두번의 메모리 접근 때문에 **Memory Access Overhead**가 발생하는데, 이를 해결하기 위해 Associative Memory인 **TLB(Translation Look-aside Buffer)** 를 이용한다. 참고로 일반 메모리는 주소에 접근해서 record를 반환하는 반면, Associative memory는 index가 존재하고 그에 매치되는 record를 통해 한 번 검사했던 레코드는 다음번 접근 시 바로 반환할 수 있게 해준다.
* **따라서 우리는 아래 그림처럼 TLB를 통해서 Page table에 접근하지 않고 frame의 위치를 가져오는 식으로 속도를 줄여보겠다는 것이다.**   
![image](https://user-images.githubusercontent.com/61929745/117565828-559d2880-b0ee-11eb-8341-3534839013b6.png)   

* 그런데 위처럼 TLB를 사용해서 frame 정보를 빨리 알아보려고 했는데 TLB 테이블에 아직 frame number가 없으면 다시 Page table을 찾아가서 frame number를 얻고, 이 녀석을 TLB에 저장해주도록 한다. TLB는 약간 Cache 느낌으로 쓴다고 생각하면 될 것 같다.
```
* 정리하면 우리는 어쨌든 Page table에 매번 직접 가서 frame number를 얻고, 실제 메모리에 접근해서 읽는 것보다는 TLB에 가서 frame number를 빨리 얻고 실제 메모리에 접근하는게 좋다는 것이다. 
```
* 이 부분에서 **Hit Ratio**와 **Effective Access Time(EAT)** 라는 개념이 있다.
* 아키텍쳐 시간에 Cache를 배울 때도 마찬가지였는데, 만약 TLB에 가서 frame 매핑 정보를 찾으려고 했는데, 없으면 페이지 테이블 가서 확인하고 업데이트하고...해줘야 하는 것이다.
```
- Hit Ratio : Percentage of times that a page number is found in TLB = r
- Effective Access Time(EAT) = (1 + X) * r + (2 + X)(1 - r) = 2 + X - r
```
* EAT에서 r은 Hit ratio를 의미하고 X는 아주 짧은 시간으로 TLB에 접근하는 시간을 의미한다.
* EAT를 최소로 만드려면 r = 1로 만들어야 하는데 이는 Hit ratio = 1을 의미하고, TLB 테이블에 거의 모든 page와 frame의 매핑 정보가 있다는 뜻이다.
* 사실 이렇게 하면 EAT는 작아져서 효율은 좋아지지만 모든 내용이 TLB에 있으려면 Associative Register가 비싸기 때문에 비용적 문제가 생기는 단점이 있다.
```
- 아무튼 이런 식으로 TLB를 이용해서 CPU 메모리에 접근하는게 효율적인 Memory Aceess라는 것이고
- 한편, TLB를 이용한 Hit ratio를 높이기 위해서는 TLB에 최대한 많은 page, frame mapping 정보가 있어야 되는데 비용적 문제도 고려해야 한다는 것이다. 
```
---

### 2) Handling Large Page Table 
* **Process마다 1개의 Page table이 존재한다면, 메모리 이슈 문제가 생긴다.**
* 예를 들어 32-bit logical address가 존재하고, 각 페이지 사이즈는 2^12 bit, page table entry의 크기는 4byte라고 하자. 그러면 page table의 size는 2^20 * 4bytes = 4Mbytes 정도가 된다. Process가 1000개면 page table의 용량만 4GB가 된다는 것이다. 뿐만 아니라, 프로세스가 돌아가고 있으면 그 프로세스의 페이지 테이블은 무조건 물리적 메모리에 존재하고 있어야 한다.
* 따라서 이렇게 큰 페이지 테이블들을 다 들고 다닐 수 없으니까 이를 해결하고자 하는 몇 가지 방법을 알아봐야 한다.

```
1) Multi-Level Paging
- 이 방법은 logical address의 공간을 여러 개의 페이지 테이블로 나누는 개념이다.
- 예를 들어 Two-Level Paging(두 단계 페이징)을 생각해보자. 1000 page짜리 책이 있을 때 1단계 페이징은 "38page 10번째 줄에 어떤 내용이 있다."고 표현한다.
- 그런데 두 단계 페이징에서는 "해당 내용이 3Chapter의 5번째 페이지의 10번째 줄에 있다."고 알려주는 것이다. 
- 따라서 모든 페이지 테이블말고 chapter table + 특정 chapter에 대한 페이지 테이블만 가지고 다니는 것이다.
- 모든 페이지 테이블을 들고 다니지 않아도 되기 때문에 메모리 이슈가 덜해지지만, Chapter -> page -> offset 처럼 Memory Access Overhead가 생기긴 한다.
- 아래 그림을 보자.
```
![image](https://user-images.githubusercontent.com/61929745/117608880-e5e47780-b199-11eb-93c5-a4edb23adaa9.png)  

```
2) Hased Page Table
- 이 방법은 32-bit 이상의 명령어 체제에서 주로 사용하는데 page table에 page number를 hash해서 집어 넣는 것이다.
- 따라서 p를 hash한 결과값으로 hash table을 검사하여 해당 물리적 메모리를 찾아가게 된다. 같은 hash 결과값에 대해서 리스트 하나를 이용할 수 있기 때문에 메모리 문제를 조금 해결할 수 있다.
```
![image](https://user-images.githubusercontent.com/61929745/117609127-64d9b000-b19a-11eb-9ec5-7ab65e2cb76f.png)

```
3) Inverted Page Table
- 이전의 테이블들은 모두 Logical address를 기준으로 한 테이블이었다. 프로세스 당 하나의 테이블을 갖고 있었고 나누어진 페이지의 순서대로 page table에 순서대로 대응되는 구조였다.
- 이 방법은 Physical address의 입장에서 만들어진 테이블 구조다. 첫 번째 프레임은 테이블의 첫번째에 저장되고, 테이블은 각 프레임은 어떤 프로세스와 대응되는지에 대한 정보를 담는다.
- 그러므로 이전에는 테이블에 단순히 몇번째 프레임인지에 대한 정보만을 담고 있었다면, 이제는 프로세스 번호인 pid 값도 담고 있게 된다.
- Inverted page table은 프로세스 당 하나의 페이지 테이블이 아니라 전체적인 하나의 테이블만 있으면 되는 장점이 있지만 테이블 크기가 커서 검색 시간이 좀 더 걸리는 단점이 있다.
- 그런데 Inverted page table에서는 테이블에 pid와 page 정보가 없으면 원래 page table에 가서 정보를 업데이트 하고...해야 되서 완벽한 전략은 아니다.
```
![image](https://user-images.githubusercontent.com/61929745/117609455-05c86b00-b19b-11eb-81f1-28deb4d0897b.png)

---

## 7. 나가면서
* 지금까지 Paging을 통한 메모리 관리 기법에 대해 공부했다. 
* 다음 글에서는 Segmentation을 통한 메모리 관리 기법에 대해 공부하고, Paging 기법과의 비교를 해볼 것이다.
