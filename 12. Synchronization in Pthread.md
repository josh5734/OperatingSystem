## 들어가면서
* 지난 글에서 Synchronization의 필요성과 Low-level solution의 관점에서 Peterson algorithm, Hardware를 이용한 Test-and-Set, Swap instruction에 대해 공부했다. 또한 High-level synchronization 기법에서 Semaphore에 대해 공부했고, semaphore는 Low level에서 존재했던 spinlock문제를 해결하여 자원 사용의 효율성을 조금 더 보장하게 했다. 하지만 semaphore 역시 deadlock 문제가 존재하기도 했으며, 여러 개의 semaphore를 관리할 때 공유 자원 접근에 대한 이슈가 있어서 Critical Region이라는 개념을 도입했다.
* 이번 글에서는 실제로 Synchronization 이슈를 Pthread가 어떻게 처리하는지 보고자 한다. Pthread는 C, C++에서 멀티쓰레딩을 구현할 때 사용하는 라이브러리로 예전에 멀티쓰레딩에 대해 정리를 했을 때 잠깐 언급했었다.

---
## Synchronization in Pthreads
* Pthreads는 두 가지 내용을 가지고 Synchronization 이슈를 처리한다.
  * 1) Condition variables
  * 2) Mutex
```
- 조건 변수(condition variables)는 쓰레드 간 동기화를 위해 사용하는 변수인데, 기본적인 동작방식은 다음과 같다.
- 하나의 쓰레드는 조건 변수에 시그널이 전달될 때까지 특정영역에서 대기 상태에 놓이게 된다.
- 만약 다른 쓰레드가 조건 변수에 시그널을 보낸다면 대기 상태에서 풀리고 다음 코드로 넘어가게 된다.
- 조건 변수는 race condition을 피해야하므로 반드시 뮤텍스(mutex)와 함께 사용되어야 한다.
```
* Contidition variables는 아래와 같은 Pthread 함수로 설정된다.
```
- pthread_cond_init() : 조건변수 'cond'를 초기화하기 위해 사용된다.
- pthread_cond_wait() : 조건변수 cond로 시그널이 전달되기를 기다린다. 이 함수는 호출되면 자동적으로 mutex잠금을 리턴한다.
- pthread_cond_timedwait() : abstime를 이용해서 제한시간이 지날 때까지 시그널이 전달되지 않았을 경우 리턴된다.
- pthread_cond_signal() : 조건변수 cond에 시그널을 보내서 다른 쓰레드를 깨운다. 만약 cond에서 기다리는 쓰레드가 없으면 아무 일도 일어나지 않게 된다.
-                         만약 여러 개의 쓰레드가 cond에서 기다리고 있다면 정호가히 이 중 하나가 깨어나게 된다. 그러나 어떤 쓰레드가 깨어날지 알 수는 없다.
- pthread_cond_broadcast() : 조건변수 cond에서 기다리는 모든 쓰레드를 깨운다. 
- pthread_cond_destroy() : 조건변수를 삭제해서 자원을 되돌려준다.
```
* Mutex에 관한 Pthread 함수는 아래와 같다.
```
- pthread_mutex_init() : mutex를 동적으로 초기화해주기 위해 사용한다. mutex를 사용하기 전에 초기화가 필요하다.
- pthread_mutex_lock() : mutex를 이용하여 critical section에 진입할 때 그 코드 구역을 잠궈서 다른 쓰레드가 진입할 수 없도록 한다.
- pthread_mutex_unlock() : critical section에서 나갈 때 mutex를 풀어서 다른 쓰레드가 접근할 수 있도록 한다.
- pthread_mutex_destory() : mutex 객체를 삭제하고 자원을 되돌려 준다. 더 이상 사용하지 않는 뮤텍스는 이 함수를 이용해서 삭제하도록 한다.
```

* condition variable과 mutex를 이용한 예제를 보자. 이전에 다뤘던 Producer, Consumer의 예제다.
```c
pthread_mutex_t mutex;                  // mutex를 선언한다.
pthread_cond_t not_full, not_empty;     // condition variable로 not_full, not_empty를 선언한다.
buffer resources[N];                    // producer, consumer가 사용하는 buffer 선언

void add_entry(resource x){
    pthread_mutex_lock(&mutex);         // mutex를 잠군다. - 이 부분만 빼면 Monitor랑 똑같다.
    while(array "resource" is full){    // 만약 현재 resource가 full 이라면
        pthread_cond_wait(&not_full, &mutex);   // not_full로 시그널이 전달되기를 기다리고, 이 함수가 호출되면 자동적으로 mutex잠금을 리턴
    }
    add "x" to array "resources";       // resouce에 x 추가
    pthread_cond_signal(&not_empty);    // 작업을 끝낼 때 기다리고 있는 다른 쓰레드를 깨워본다.
    pthread_mutex_unlock(&mutex);       // 다른 쓰레드가 접근할 수 있도록 mutex 잠금을 해제한다. 
}
void remove_entry (resource *x){
    pthread_mutex_lock(&mutex);         // mutex를 잠군다.
    while (array "resource" is empty){  // 만약 현재 resource가 empty라면
        pthread_cond_wait(&not_empty, &mutex);  // not_empty로 시그널이 전달되기를 기다리고, 이 함수가 호출되면 자동으로 mutex 잠금
    }
    *x = get resource from array "resources"    // resource로부터 자원을 하나 뺀다.
    pthread_cond_signal(&not_full);             // 작업을 끝낼 때 기다리고 있는 다른 쓰레드를 깨운다.
    pthread_unlock_mutex(&mutex);               // 다른 쓰레드가 접근할 수 있도록 뮤텍스 잠금을 해제
}
```
---
* 지금까지 pthread를 이용해서 condition variable과 mutex를 어떻게 관리하는지에 대해 개념과 예제를 살펴봤다.
* 동기화 이슈는 너무 복잡하고 처리하는 방식이 다양해서 시험공부를 하면서 조금씩 빈 부분을 채워나가야겠다.
