## 1. 프로세스(Process)란?
* 프로세스란 간단히 정의해서 실행 중인 프로그램을 의미한다.(=Program in Execution)
* 그렇다면, 실행 중인 프로그램은 무엇으로 구성되어 있을까? 
<img src = "https://user-images.githubusercontent.com/61929745/115347110-f97c6e00-a1eb-11eb-9ba1-533096c84545.png" width = 300, height = 300>   

```
- 위 그림처럼 프로세스는 크게 Image 영역과 Process context 영역으로 구분되어 있다.
- Image는 RAM에 존재하는 실제 Code, Data, Stack, Heap 등의 내용이 포함된다.
- Process Context에는 Data register, $PC, $SP 등이 존재한다. 
- 여기에 있는 register, pointer 등이 실제 이미지에 존재하는 데이터를 처리하고 포인팅할 수 있게 한다.
```
* 그렇다면 프로세스의 구조 중에서 Image 영역에 대해 조금 더 자세하게 알아보자.
![image](https://user-images.githubusercontent.com/61929745/111899320-3deedf80-8a6f-11eb-8763-485e6a56e5ea.png)   
출처:https://lenir.github.io/2017/10/23/Study-OS/   

```
- 프로세스의 이미지(Image) 구조는 위와 같다. 제일 작은 메모리 주소 부분에는 실행가능한 Code(read-only)를 저장한다.
- 프로그램을 시작할 때 컴파일한 기계어가 저장된다. 그 위에는 초기화해서 변하지 않는 변수를 저장하고, 다시 그 위에 아직 초기화하지 않은 전역 변수나 정적(static) 변수를 저장한다. 
- 이 때, 아직 초기화되지 않은 data 부분은 프로그램이 실행되기 전에 커널에 의해 자동으로 0으로 초기화된다.

- Stack 메모리에는 지역 변수, 임시 변수, 매개 변수, return value, return address주소 등이 저장된다.
- 여기서 return address란 무엇이냐 하면, 예를 들어 우리가 function1()을 호출하고 그 결과를 다시 main이나 다른 함수에 return해야 할 때, 돌아갈 곳을 명시해주는 주소를 담는 공간으로 이해하면 될 것 같다. 
- Stack 영역은 컴파일 타임에 크기가 결정되기 때문에 무한히 할당할 수가 없다. 예를 들어 재귀함수가 너무 깊게 호출되거나 함수가 지역변수를 너무 많이 가지고 있어서 Stack 영역을 초과하면 StackOverflow에러가 발생하는 것이다.

- Heap 메모리 영역에는 프로그램 런타임에 동적 메모리가 할당된다. 
- C언어에서 malloc, calloc으로 Heap 영역의 메모리를 사용할 수 있다. 데이터 배열의 크기가 확실하지 않고 변동이 있을 때 Heap 영역을 활용해서 메모리를 할당한다.
- 단, 사용하고 난 다음에는 반드시 해제를 해야하는데 그렇지 않으면 메모리 누수가 일어날 수 있다.
```
---

## 2. PCB(Process Control Block)
* 처음에 우리는 프로세스를 실행 중인 프로그램이라고 했다. 이를 조금 다르게 정의해보면 프로세스는 곧 실행 가능한 PCB를 가진 프로그램이라고 볼 수도 있다.
```
- PCB는 운영체제가 프로세스를 제어하기 위해 정보를 저장해 놓는 곳으로, 프로세스의 상태 정보를 저장하는 구조체라고 생각하면 된다.
- 우리가 일반적으로 프로그램을 돌릴 때, 많은 수의 프로세스가 돌아가게 되고 이러한 프로세스들은 Time Sharing을 하거나 서로 참조하는 등으로 문맥 교환을 하게 된다.
- 이를 위해서는 각 프로세스의 상태를 저장해야 하고 이러한 맥락에서 PCB가 필요한 것이다.
```   
<img src = "https://user-images.githubusercontent.com/61929745/111899813-22d19f00-8a72-11eb-9b7a-93ff54321dae.png" width = 400 height = 400>   

출처: https://jhnyang.tistory.com/33
  * Process ID: 프로세스의 고유 번호
  * Process State: 프로세스의 준비, 대기, 실행 등의 상태
  * Process Counter(Pointer): 프로세스가 다음에 실행할 명령어의 주소
  * Register information: 레지스터는 메모리 연산을 처리하기 위해서 임시로 가지고 있는 기억 공간인데 CPU옆에 붙어 있다. 이에 대한 정보를 가지고 있어야 한다.
  * Scheduling information: 스케쥴링 및 프로세스의 우선 순위 등을 가지고 있다.
  * Memomry related information: 할당된 자원의 정보를 가지고 있다.
  * Accounting information: 프로세스를 처리하고 있는 CPU의 사용시간, 실제 사용된 시간 등을 담고 있다.
  * Status information related to I/O: 입출력 상태 정보를 가지고 있다. 프로세스에 할당된 입출력장치의 목록이나 열린 파일 목록 등을 저장한다.
 ---
 
 ## 3. Process State
 * 당연하게도 우리는 여러 프로세스를 동시에 처리해야 하기 때문에 프로세스는 실행되는 동안 계속해서 상태가 변한다. 이에 대해서 공부해보자.   
 ![image](https://user-images.githubusercontent.com/61929745/111900017-6b3d8c80-8a73-11eb-95a0-6c0aec4318ef.png)   
 
 출처: https://slidesplayer.org/slide/16639186/
  * New: 프로세스가 생성된 상태
  * Ready: CPU를 할당받기 위해 준비중인 상태
  * Blocked(Waiting): 어떤 이벤트를 기다리고 있는 상태
  * Running: Instruction(명령어)가 실행되고 있는 상태
  
* 위 그림을 이해하고 하나의 예시를 생각해보자.
```
1. 예를 들어 우리가 System Call을 호출하면 해당 프로세스는 Blocked 상태로 변한다.
2. 그동안 CPU는 다른 Process를 돌려야 한다. System call을 호출하는 동안 CPU가 아무일도 하고 있지 않으면 낭비이기 때문이다.
3. System operation이 끝나면 다시 CPU에게 Interrupt를 발생시킨다.
4. Interrupt를 받은 CPU는 현재 실행 중인 프로세스를 멈추고, 커널 모드로 돌아가 Interrupt를 Handling한다.
5. 이후에 이전 프로세스를 다시 Ready 상태로 돌려놓는다.
```
* 이러한 내용을 그림으로 정리해보면 아래와 같을 것이다.
<img src = "https://user-images.githubusercontent.com/61929745/115348878-2467c180-a1ee-11eb-817f-80b47a6a147b.png" width = 400 height = 300>

---

## 4. Mode Switching
* 이전 정리글에서도 언급했던 것 같은데, User-Kernel Mode Switching은 세 가지 상황에서 일어난다.
 * 1. Hardware Externel interrupt(Timer, I/O Interrupt)
 * 2. Software Exception(Page fault, invalid operations..)
 * 3. System Call(I/O Operation, fort()..)

#### Mode Switching의 과정
```
1. 현재 프로세서의 상태를 저장한다.
2. 프로그램 카운터를 다음 작업을 할 주소값으로 세팅한다.
3. 커널 모드로 전환하여 수행해야 하는 Instruction을 핸들링할수 있도록 한다.  
```
---

## 5. Process Switching
* 사실 Process State를 변환하면서 Process Switching을 하는 과정은 상당히 복잡하다. 진행 중이던 프로세스의 상태를 기록하고, 불러오는 프로세스의 이전 상태를 복원해야 한다. 또한 각 프로세스를 저장할 큐의 메모리 위치를 선점하는 등의 작업이 필요하다.
* 한편, Process Switching은 Mode Switching과는 구분되는 개념이다. 이전 자료에서 공부했던 것처럼 Mode switching은 User mode, Kernel mode를 변환하는 과정이지만, Process switching은 프로세스의 상태를 변화시키는 과정 전체를 의미하는 것이다.

### - Process Swtiching의 과정(중요)
```
- 0. Process switching은 Mode Switching의 결과로 발생한다! 다시 말해서, 앞에서 배운 Interrupt, Exception, System Call이 일어나면 Process swtiching이 일어나는 것이 아니라 Mode Swtiching이 일어나는 것이다.
- 1. Process Switching이 일어나면 우선 현재 프로그램 컨텍스트(Program context)를 저장한다.
- 2. 현재 프로세스의 상태(Running)를 blocked, ready, exit 등으로 바꾼다.
- 3. Process Control block(PCB)를 적절한 큐로 이동시킨다.
- 4. 프로세스 스케쥴링에 따라 다음에 수행할 프로세스를 선정한다.
- 5. 수행할 프로세스의 PCB를 적절한 큐로 이동시킨다.
- 6. 수행할 프로세스의 Process State를 Running으로 변환한다.
- 7. 수행할 프로세스의 이전까지 작업했던 Program context를 복원하고 작업을 수행한다.
---
