## 들어가면서
* 동기화(Synchronization)의 사전적 의미는 **시스템을 동시에 작동시키기 위해 여러 사건들을 조화시키는 것**이다.
* 이전에 멀티프로세싱과 멀티쓰레딩에 대해서 공부했는데, 동기화 이슈는 이러한 멀티태스킹 환경에서 정말 중요한 역할을 한다.

---
### 1. Synchronization은 왜 필요한가?
* 멀티쓰레딩에 대해 공부했을 때를 떠올려보자. 
* 멀티쓰레딩이란 기본적으로 프로세스 이미지를 공유 가능한 부분과 공유 가능하지 않은 부분으로 나눠서 공유 가능한 부분을 Thread란 개념으로 나눈 것이다. 이전에 정의했던 내용을 다시 보자.
```
* 멀티쓰레딩은 공유 가능한 Shared libraries, runtime heap, read/write data, read-only code/data 그리고 Kernel Context는 하나로 두고
* 특정 시점의 Program Counter(PC)에 따라 Stack 내용이 달라지기 때문에 개별적으로 가지고 있어야 하는 User stack 부분으로 나누는 것.
```
* 여기서 **여러 개의 쓰레드가 같은  Global data를 사용하려고 하면 어떻게 될까?** 에 대한 내용을 다루는 것이 동기화 이슈라고 생각하면 된다.
* 즉, **Shared Data에 대해 아무런 통제를 해주지 않으면 어떤 프로세스나 쓰레드가 이 데이터를 읽고 쓰고 있을 때 다른 녀석이 들어와서 읽고 쓰게 되버릴 수 있는 것이다. 그렇게 되면 결국 프로그램의 수행 결과가 Non-Deterministic하게 된다는 문제를 다루는 것이다.**   
   
* 아래 예시를 보자.
```
// Producer = 데이터를 추가하는 역할(counter 증가)
register A := counter;          // load
register A := registerA + 1;    // add
counter := registerA;           // store

// Consumer = 데이터를 빼는(소모하는) 역할(counter 감소)
registerB := counter;           // load
reigsterB := registerB - 1;     // sub
counter := registerB;           // store
```
* 위 상황에서 만약 현재 counter = 5라고 해보자. 만약 동기화 이슈에 대한 처리를 하지 않았을 때 어떤 상황이 일어날까?
    - * 1. Register A, B가 counter 변수를 동시에 Load
    - * 2. A는 +1을 하고, B는 -1을 한다.
    - * 3. A가 counter를 store하고, B가 store하면 최종 counter는 4가 되어버린다.
    - * 만약 B가 먼저 store하면 결과는 6이 되어버린다.
* 위와 같은 대참사를 **Race Condition**이라고 부른다. 한마디로, 프로그램의 수행 결과가 예상하는 대로 안나오는 상황이다.
* 그래서 우리는 이런 사태를 방지하기 위해 동기화(Synchronization)를 신경써야 하는 것이다.   
   
* 지금까지 이야기 한 내용을 그림을 통해서 보면 아래와 같다.
<img src = "https://user-images.githubusercontent.com/61929745/114378107-5790cc00-9bc2-11eb-9b3c-e2e716ccb62b.png" width = 400 height = 200>   

* 첫번째 그림은 User level에서 한 data에 대해 여러 쓰레드가 접근하는 것이고, 두번째 그림은 Kernel 영역에 있는 data에 대해 여러 System Call 핸들러가 접근하는 것이다. 세번째 그림은 Kernel 영역의 data에 대해 System call 핸들러와 Interrupt 핸들러가 접근하는 것이고 마지막은 두 개의 Interrupt 핸들러가 접근하는 것이다. 이런 식으로 Kernel의 global data가 공유될 수 있으면 위와 같은 Race Condition 문제가 생기게 된다.

---
### 2. Critical Section
* Critical Section은 위에서 동기화 문제가 발생한 Global Data 영역을 가리키는 말이다. 각각의 프로세스는 코드 조각 안에 Critical Section이 존재하는데 그 안에서 공유 데이터에 대한 접근을 컨트롤하게 된다.   
<img src = "https://user-images.githubusercontent.com/61929745/114378807-092ffd00-9bc3-11eb-905d-e927dffdee11.png" width = 400 height = 300>   

* Critical Section을 코드로 구현하는 아이디어는 간단하다.
```
Critical Section에 접근하기 전에 프로세스는 "입장한다"라는 신호를 Lock을 건다.      // Entry Section
Critical Section에서 나갈 때는 Lock을 해제하여 다 썼음을 표시한다.                  // Exit Section
```
* 보다 구체적으로 Critical Section을 구현하기 위해서는 아래와 같은 조건이 충족되어야 한다.
```
1. Mutual Exclusion: 내가 쓰면 다른 프로세스는 못 쓰게 하는 것
2. Progress: 다른 프로세스가 쓰고 있지 않으면 내가 쓸 수 있는 것
3. Bound Waiting: 다른 프로세스가 쓰고 있으면 기다리되, 기다리는 시간에 bound를 설정하는 것
```
* 실제로 Critical Section을 구현하는 데는 크게 두 가지 방법이 존재한다.
1. **Low-level Synchronization primitive - Locks**
    - 기본적인 방법으로 Locks 개념을 기반으로 크게 세 가지 방식으로 구분할 수 있다. 우선 lock에 대해 조금 이야기해보자.
    ```
    - lock은 쉽게 말해서 화장실에 들어갈 때 노크를 해서 안에 사람이 있으면 기다리고, 화장실을 쓰는 사람은 문을 잠그고 사용하고 나올 때 문을 여는 개념이다. 아래 두 가지 기능을 보자
    - acquire() / lock() : Lock이 열릴 때까지 기다렸다가 열리면 데이터를 사용가능한 상태로 갖는다.
    - release() / unlock() : 기다리고 있던 프로세스나 쓰레드에게 이제 사용할 수 있다고 알려준다.
    - lock은 처음에는 아무도 걸지 않은 상태로 시작하고, Critical Section에 진입하기 전에 Lock을 건다. 그리고 떠날 때 unlock()을 하면 된다. 
    - 무조건 하나의 프로세스나 쓰레드만이 lock을 걸고 사용할 수 있다.
    ```
    1) Software-only solution 
    2) Hardware atomic solution 
    3) Disabling interrupts 

2. **Semaphore, Monitor 등**

- 여기까지 정리 -
