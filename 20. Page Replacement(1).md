# 0. 들어가면서
* 지난 시간에 가상 메모리의 기본적인 개념에 대해 공부했고, 한정된 Physical Memory에 많은 양의 Locial Memory를 load하기 위한 Demand paging 전략에 대해 살펴봤다.
* Demand Paging은 필요한 페이지만 RAM에 올려둠으로써 메모리 문제를 해결해준다고 기대했는데, 하지만 여기서 **Page fault** 문제가 필연적으로 발생할 수밖에 없다고 했다.
* 이번 시간에는 이러한 Page fault를 어떻게 핸들링할 것인가에 대해 Page Replacement 개념과 정책들에 대해 알아보겠다.
---

# 1. Page Replacement의 어려움
```
- Page fault를 핸들링하는 데 가장 어려운 점은 어떤 페이지를 Swap out할 것인가에 관한 문제다.
- 여기서 어떤 페이지를 Swap out할 것인가에 대한 기준은 미래에 Page fault를 최소로 일으키게 하는 녀석으로 생각할 수 있는데,
- 사실 미래에 프로세스가 어떻게 작동될 지 완벽한 예측을 할 수 없기 때문에 결코 쉬운 일은 아니다.
```
---

# 2. Page replacement Scheme
* 교과서에서는 아래와 같이 Page replacement에 대한 Basic Scheme을 정해두고 있다.
* 하지만 먼저 기억해야 될 점은 실제 OS는 이러한 방식을 그대로 따르지 않는다는 것이다.
```
- 실제 OS는 Background에서 항상 어느 정도의 빈 frame을 확보하기 위한 작업을 하고 있다.
- 이를 통해 Page fault가 일어날 때마다 일일이 Swap out하고 page table과 frame table을 바꾸는 overhead를 줄이려고 한다.
```
* 그렇다면 교과서에서 정하는 Basic Scheme은 어떤 것인지 아래 설명과 그림을 통해 살펴보자.
```
1. Find the location of the desired page on disk
2. Find a free frame:
    - if there is a free frame, use it
    - if there is no free frame, use a page replacement algorithm to select a victim frame
3. Read the desired page into the newly free frame
4. Update the page and frame tables
5. Restart the process
```

![image](https://user-images.githubusercontent.com/61929745/118434715-7bdb4d80-b718-11eb-8bc0-e5ea2645749a.png)   

* 위 그림을 보면 프로세스의 page f가 현재 physical memory에 올려져 있고, PC(Program Counter)는 그 다음 page를 가리키고 있다.
* PC가 가리키는 page가 physical memory에 없기 때문에 page fault가 일어나며, 이를 핸들링하기 위해 기존의 page f를 swap out하겠다고 결정한다(가정).
* 그러면 빈 free frame이 생기게 되고 거기에 현재 필요한 page를 load하고, page table의 present bit와 frame 정보를 업데이트한다.
* 위와 같은 과정을 통해 page replacement가 일어난다.
---
# 3. Page Replacement Algorithms
* Page Replacement가 어떻게 일어나는지는 크게 어렵지 않게 이해할 수 있다.
* 하지만 가장 큰 문제점은 **그래서 결국 어떤 페이지를 지금 Victim으로 쫓아낼 것이냐?** 를 결정하는 게 쉬운 일이 아니라는 것이다.
* 그래서 기본적으로는 앞으로 정말 오래 안 쓸 것 같은 Page를 Victim으로 쫓아내자는 아이디어(?)가 존재하게 되는데, Belady라는 사람이 실제로 가장 오래 안쓸 것 같은 페이지를 지금 쫓아내는 것이 미래에 Page Fault를 가장 적게 일으키는 것임을 증명하는 데 성공했다.
* 아무튼, 우리가 지금 알아보고자 하는 것은 어떤 녀석을 쫓아내야 Page fault rate이 최소가 될 것인가를 예측하는 것이고 이에 대한 여러 가지 정책을 아래에서 하나씩 살펴보도록 하자.
---

* 페이지 교체는 매우 다양한 정책을 통해 이루어질 수 있고, OS가 지금 소개하는 페이지 교체 정책을 그대로 갖다 쓰지도 않는다.
* 다만 지금은 예전에 CPU Scheduling에서 FIFO, Round-Robin, SJF 등에 대해 공부했을 때와 마찬기지로, **어떠한 개념이 어떤 이유에서 좋고 나쁜지를 생각해보면 될 것 같다.**

## 1) Optimal Algorithm
```
- Optimal 알고리즘은 앞으로 가장 오랫동안 안 쓸 페이지를 Victim으로 삼는 것이다.
- 딱히 설명이 필요할 내용은 없고, 아래 그림을 보면 쉽게 이해될 것 같은데 주의해야 될 점은 Optimal한 정책이 Page fault를 0으로 만든다는 것은 아니다.
- 또한, 현실적으로 이 알고리즘은 미래를 예측할 수 없기 때문에 사용할 수 없다. 다만, 다른 교체 정책과 비교할 base line으로 역할하는 것이다.
```
![image](https://user-images.githubusercontent.com/61929745/118786243-935b3780-b8cc-11eb-81c0-fefcedf4b769.png)


## 2) FIFO Algorithm
```
- FIFO 알고리즘 역시 매우 간단하다. Page fault가 발생하면 physical memory에 먼저 들어오면 page부터 Victim으로 삼는다.
- FIFO 알고리즘은 치명적인 약점을 하나 갖는데, 내 프로세스에 더 많은 frame을 할당하더라도, page fault가 줄어들지 않을 수 있다는 것이다. 
- 애초에 Page fault가 일어나는 원인이 한정된 frame 공간 때문인데, frame을 더 줘도 page fault가 줄어들지 않는다면 무슨 의미가 있을까?
- 아래 그림을 보면 FIFO 알고리즘의 기본적인 동작 방식과 frame 수가 늘어나도 performance가 좋아지지 않는 상황을 볼 수 있다.
```

![image](https://user-images.githubusercontent.com/61929745/118795286-652e2580-b8d5-11eb-9005-9d93be9a4665.png)


## 3) LRU(Least Recently Used) Algorithm
```
- LRU 알고리즘은 실제로 Linux OS에서도 발전시켜서 사용하는 중요한 페이지 교체 정책이다.
- LRU는 현재 time을 기준으로 가장 오랫동안 쓰지 않았던 녀석을 Victim으로 선정하는데, 이는 앞서 말한 Locality에 기반한 정책으로 볼 수 있다.
- 실제로 LRU 알고리즘은 꽤나 괜찮은 성능을 보이기도 하는데, 아래 그림을 보자.
```

![image](https://user-images.githubusercontent.com/61929745/118795519-a0305900-b8d5-11eb-9997-570250b7cf11.png)

* 위 그림을 보면 time = 5일 때, e가 들어오기 위해서는 c가 swap out된다. c가 가장 오랫동안 사용되지 않았기 때문이다.
* 한편, LRU 알고리즘에는 중요한 이슈가 하나 있다. 어떻게 가장 오랫동안 쓰이지 않은 page를 알아낼까?
* 이에 대해서는 counters, stack을 이용한 방법이 존재하는데 각각에 대해 알아보자.
### 1) Stack을 이용한 Implementation
```
- 아래 그림처럼 가장 최근에 사용한 page들을 기록하기 위해 스택을 사용한다.
- 스택의 맨 위에는 가장 최근에 사용한 page가 존재하고, 스택의 바닥에는 가장 오래 쓰이지 않은 page가 존재한다.
- time = t에서 어떤 페이지를 사용하면 그 페이지는 stack의 맨 위로 올라오고, 만약 page fault가 발생하면 스택 맨 아래의 page를 제거한다.
- 크게 어렵지 않으니 아래 그림을 통해 이해하면 될 것 같다. 
```
![image](https://user-images.githubusercontent.com/61929745/118796104-3cf2f680-b8d6-11eb-8c34-439365cab887.png)

### 2) Counting을 이용한 Algorithm 
```
- 이 알고리즘은 각 페이지가 참조될 때마다 count 값을 1씩 증가시킨다.
- 그리고 여기서 LFU(Least Frequently Used) 알고리즘을 쓰면 count값이 가장 적은 녀석을 날려버린다. 잘 안쓰면 날려버린다는 것이다.
- 한편 MFU(Most Frequently Used) 알고리즘을 쓰면 count값이 가장 큰 녀석을 날려버린다. 이미 쓸만큼 써서 이제 필요없다는 해석이다.
- 그리고 오히려 count값이 작은 것을 이 page가 아직 사용된 지 얼마 안되서 앞으로 많이 쓰일 것이라고 생각하는 것이다.
```

### 3) Hardware support for Replacement
```
- 예전에 page entry의 여러가지 flag bit들에 대해 공부했었다. 여기서 reference bit는 이 페이지가 refer되면 1, 그렇지 않으면 0의 값을 갖는다.
- 또한 reference bit는 OS에 의해서 일정 시간이 지나면 0으로 바뀌게 되는데, 이를 이용해서 대략적인 LRU를 찾는 것이다.
- 대략적인 LRU를 찾는다는 게 무슨 말이냐면, 정확히 가장 오랫동안 쓰이지 않은 page를 찾아내려면 overhead가 크니까 "최대한 예전에 사용한 녀석을 찾자"는 것이다.
- reference bit를 이용해서 LRU algorithm을 구현하는 방법은 또 다시 2가지가 존재하는데, Sampled LRU, Clock algorithm이다. 각각에 대해 알아보자.
```
#### 3-1. Sampled LRU
- Sample LRU는 아래 그림처럼 각 페이지마다 계속해서 reference bit를 기록해나가는 것이다. 구체적인 과정은 아래와 같다.
```
- 일정한 time interval마다 interrupt를 걸고, OS가 각각의 페이지에 대한 reference bit를 읽는다.
- 각 페이지의 현재 reference bit를 reference bytes라는 메모리의 MSB(Most significant bit)에 기록하고, LSB는 삭제한다.
- 그러면 만약 page fault가 일어났을 때 각 페이지의 reference bytes를 체크해서 그 값이 가장 작은 놈을 victim으로 삼는 것이다.   
```
![image](https://user-images.githubusercontent.com/61929745/118797229-52b4eb80-b8d7-11eb-903b-15db634e58a1.png)

#### 3-2. Clock Algorithm
- Clock algorithm은 LRU clock 또는 Second-Chance라고 불린다. 
- 이 알고리즘은 FIFO 개념과 LRU 개념을 약간 섞어놓은 느낌인데, 구체적인 과정은 아래와 같다.
```
- 매번 reference가 발생할 때마다 page의 reference bit는 1로 설정된다.
- page fault가 발생하면, clock은 원형으로 배치된 page들을 쓸고 지나가면서 reference bit을 0으로 바꿔놓는다.
- 그리고 다시 clock이 한 바퀴 돌고 돌아왔을 때, 여전히 reference bit이 0이면 그 녀석은 그 clock이 도는동안 쓰이지 않았다고 보고 날려버리는 것이다.
```
![image](https://user-images.githubusercontent.com/61929745/118797970-159d2900-b8d8-11eb-9eba-48aa180dcb89.png)   
```
- 한편 Two-handed Clock Algorithm도 존재하는데, 이는 기본적인 Clock algorithm과 개념은 똑같은데 쓸고 지나가는 시계침이 두 개라고 생각하면 된다.
- 그러니까 먼저 fronthand가 page들을 지나가면서 reference bit를 0으로 설정하고, 그 다음에 backhand가 오기 전까지 페이지가 사용되면 1로 변하는 것이다.
- 그래서 backhand가 도착했을 때 여전히 reference bit가 0이면, 위와 마찬가지로 날려버리는 것이다.
```
![image](https://user-images.githubusercontent.com/61929745/118798062-336a8e00-b8d8-11eb-84eb-0a10e4035e46.png)

---

# 4. 나가면서
* 지금까지 Page replacement의 basic scheme과 여러 가지 교체 정책에 대해 공부했다.
* 다음 글에서는 실제로 프로세스에게 얼마만큼의 frame을 할당해야 하는가에 대한 내용과 Page fault와 관련된 몇 가지 현상들에 대해서 정리하도록 하겠다. 


