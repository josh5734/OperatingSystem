## 0. 들어가면서
* 이제 가상메모리(Virtual Memory)에 대해 공부해보고자 한다.
* 가상 메모리는 Virtual 또는 Logical Memory라고 부르는데, 이전에 Memory Management를 공부하면서 사용했던 개념이다.

## 1. Concepts of Virtual Memory
```
- 가상 메모리는 프로세스가 가진 이미지의 주소 공간으로, 실제 물리적 메모리와는 독립적이다.
- 멀티프로세싱 환경에서 각 프로세스는 자신의 가상 메모리 공간을 갖고 있고, 이들을 Run time에 Physical Memory에 올려서 사용하는 것이다.
```
* 따라서 우리의 과제는 Process가 만들어내는 Virtual Address를 어떻게 Physical Address로 바꿀 것인가에 관한 것이다.
* 실제로 이전에 메모리 관리 기법에서 Partitioning, Buddy system, Paging, Segmentation 등을 배웠는데, 이 중에서 실제로 어떤 메모리 관리 기법을 발전시키고 사용하는지 보고자 한다.


## 2. Virtual Memory Techniques
* 가상 메모리 사용의 가장 핵심적인 목표는 "프로그래머가 Physical Address를 신경쓰지 않고, Logical Address에 대해서만 고민하게 하는 것"이다.
```
- 이를 위해 Multi-Processing 상황에서 각 프로세스의 가상 메모리는 서로 독립적이어야 하고, 하나의 프로세스가 터져도 다른 프로세스에게 영향이 가면 안 된다.
- 또한 모든 가상 메모리들이 통째로 물리적 메모리에 올려지는 것이 아니라, 공유 가능한 부분은 공유하고 / 실제 사용하는 영역만 올리려고 한다.

- 이를 통해서 우리가 이전 장의 초반 부분에서 던졌던 물음에 대해 답변할 수 있다.
- "RAM이 1GB라고 하면 32-bit architecture에서 각 PCB는 4GB이고 수 천개의 프로세스가 돌아가는데, 어떻게 이 주소들을 RAM에 올리는 것일까?
- 이 물음에 대한 답을 "모든 가상 메모리를 물리적 메모리에 올리지 않고, 필요한 부분만 + 공유 가능하면 한 번만 올리는 것"으로 대답할 수 있다.
```
* 이제 실제로 이 과정을 구현하는 방법인 **demand Paging** 개념에 대해 알아보자.
---

## 3. Demand Paging
* Demand Paging은 이름 그대로 필요한 부분의 페이지 영역만 물리적 메모리에 할당하는 것이다.
* 이전 장에서 우리는 **Swapping에 대해 배웠는데** 여기서 이 개념이 아래와 같이 살짝 바뀐다.
```
기존 Swapping: 물리적 메모리에 존재하는 프로세스 자체를 HDD 등 Storage로 뺐다가 재배치했다가 하는 과정
-> 새로운 Swapping: 물리적 메모리에 존재하는 프로세스의 "페이지" 일부를 뺐다가 재배치했다가 하는 과정
```
* 위와 같은 Swapping 개념의 변화를 통해 우리는 **한 시점에서 빈번히 쓰이는 페이지만 물리적 메모리에 담아서 사용하게 된다.**
* 아래 그림을 보자.   
![image](https://user-images.githubusercontent.com/61929745/117920656-37bc0780-b32a-11eb-918b-40d586e073d7.png)
```
* 그림을 보면 맨 왼쪽의 프로세스가 가지는 여러 개의 페이지 중에서 실제로 물리적 메모리에 올라가 있는 것은 A, C, F밖에 없다.
* 프로세스가 돌아가는 동안 MMU는 실시간으로 Page table을 확인하고, 필요한 Page가 Physical Memory에 있으면 사용하면 된다.
* 그림의 Page table을 보면 Present bit을 볼 수 있는데, 이 비트가 1인지 0인지 확인해서 물리 메모리에 해당 페이지가 저장되어 있는지 알 수 있다.
* 만약 Present bit이 0이면, 사용하려는 페이지가 물리적 메모리에 지금 없다는 뜻이 되는데, 이 때는 해당 page table의 entry에 Storage의 어느 위치에 필요한 Page가 저장되어 있는지 써 있다.
```
* 하지만 위에서 말했다시피, 필요한 페이지가 지금 물리적 메모리에 없는 상황이 필연적으로 발생한다. RAM의 무한정 크지는 않기 때문이다.
* 이 상황을 우리는 **Page Fault**라고 부르고 이것을 관리하는 이슈를 Page fault Handling이라고 한다.
---

## 4. Page fault Handling
* Page Fault Handling은 내가 가진 모든 Page가 RAM에 존재하는 게 아니기 때문에 필연적으로 일어날 수밖에 없다.
* 그렇다면 이런 상황을 어떻게 대처할까? 우선 기본적인 Page fault handling 메커니즘을 아래 그림을 통해 이해해보자.   
![image](https://user-images.githubusercontent.com/61929745/117946974-bc1e8280-b34a-11eb-996f-2d64a62dde66.png)
```
1) 프로세스는 자신이 사용하고자 하는 페이지가 page table에 존재하는지 확인한다.
2) 만약 physical memory에 사용하려는 page가 없으면, Page fault exception이 발생하고 커널모드로 전환된다.
3) OS는 page table entry의 정보 속에서 Backing storage의 어느 위치에 page가 존재하는지 확인한다.
4) 필요한 페이지를 physical memory에 load한다.
5) page table를 다시 업데이트 해준다.
6) 그리고 이제 원래 하려고 했던 instruction을 수행해준다.

- 근데 여기서 하나 문제가 있다. 애초에 지금 찾는 page가 backing store에 있다는 것은 physical memory가 꽉 차있거나, 그 경우를 우려한 것일텐데...
- 만약 backing store에서 page를 다시 불러오려면, 기존에 physical memory에 존재하는 **어떤 페이지를 다시 빼야 할까?**
- 이에 대한 개념이 page 교체 정책인데, 추후에 다시 알아볼 것이다.
```
---
## 5. Performance
* 위에서 살펴본 page fault는 얼마나 일어날까? 그리고 이것을 handling만 잘하면 괜찮을까?
* 예전에 TLB를 통한 Paging 기법처럼 이러한 page fault handling에도 성능 이슈가 존재한다.
```
- Page fault handling을 위해서는 크게 3단계 Page-fault-interrupt -> Read in the page -> Restart the process 과정이 필요하다.
- 그런데 이 때, 앞 뒤 두 단계는 크게 시간이 안 걸리지만, backing store에서 페이지를 찾아오는 과정이 꽤 긴 시간이 소요된다.
- 그래서 우리가 만약 10%의 성능 저하 정도는 메모리를 아끼는 대신에 감수한다고 쳐도 2,500,000번 중에 1번만 page fault가 뜨면 10%가 성능이 저하된다.
- 근데 현실적으로 2,500,000번 중에 1번만 page fault가 뜨는게 가능할까??
```
* 위 질문에 대한 답을 하기 위해서는 **Locality**라는 개념을 알 필요가 있다.
* 컴퓨터 아키텍쳐 시간에서도 비슷하게 배운 내용인데, 실제로 우리가 사용하는 코드를 생각해보면 거의 대부분의 코드가 Loop, 사용한 코드의 재사용 등으로 이루어져있다.
* 이를 Locality(지역성)이라고 하는데, Locality 덕분에 한 번 사용하려는 Page를 page table에 넣어놓으면 한동안 주구장창 사용하다가 코드 구역이 넘어가면 swap out하면 된다.
* Locality는 크게 두 가지가 있다.
1) Temporal Locality: 우리 코드는 어떤 작업을 하기 위해 비슷한 시간에 어떤 페이지 영역을 지속적으로 쓰고, 그 일을 끝내면 다시 그 영역을 잘 쓰진 않는다는 것
2) Spatial Locality: loop문처럼 코드가 어떤 구역에서는 비슷한 page 정보를 사용하다가, 다른 영역으로 넘어가면 그 페이지를 재차 잘 쓰지는 않는다는 것
```
- 따라서 위의 Locality 개념 덕분에 page fault는 우려하는 것만큼 빈번히 일어나지 않는 것이다.
- 하지만 Locality가 잘 지켜지지 않는 코드도 분명 있기 때문에 항상 page fault 성능 이슈를 해결할 수 있는 것은 아니다.
```
---
## 6. 나가면서
* 기본적인 Virtual Memory의 개념에 대해 공부했다.
* 이번 글에서 중점적으로 다룬 내용은 어떻게 커다란 메모리의 Virtual memory들을 작은 Physical memory에 넣어서 사용하는가였다.
* 다음 글에서 더 구체적인 내용을 정리할 것 같다.
