## 0. 들어가면서
* 이번 글에서는 하드디스크의 구조에 대해 간략하게 알아보려고 한다.

## 1. Disk 구조
* 아래 그림을 보자.   
![image](https://user-images.githubusercontent.com/61929745/120423396-46379500-c3a5-11eb-8b16-c1631e336eae.png)

```
- 디스크는 Cylinder, platter, Track, Sector, Head 등으로 구성되어 있다.
- N장의 platter를 겹쳐놓은 것을 Cylinder라고 하며, 각 Platter에 대해 Head가 존재하는 구조다.
- 각 Flatter는 왼쪽그림과 같이 Track과 Sector로 구분되고 Track은 platter의 중심으로부터 일정 거리 떨어진 Sector들의 집합으로 볼 수 있다.
- 여기서 한 가지 추측할 수 있는 부분은 중심에서 멀어질수록 각 sector의 크기가 커진다는 것이다.

- 한편 이제 우리가 고민해야 하는 부분은 "어떻게 각각의 Platter의 sector 영역에 데이터를 읽고 쓸까?"이다.
```
---
## 2. Read/Write Operation to a Disk
* 위 그림에서 알 수 있듯이, 하나의 Platter에 대해서는 하나의 Head가 존재한다.
* 따라서, Head는 우리가 원하는 Target track을 찾기 위해 움직여야 하고(= Seek time)
* 이제 Track을 찾았으면 하드디스크가 회전하면서 원하는 Sector가 오기까지 기다려야 하는 한다. (= Rotational latency)
* 마지막으로 해당 Sector에 데이터를 읽고 쓰는 시간(= Transfer time)이 필요하다.
- 따라서, Read/Write time은 아래와 같이 정리될 수 있다.
```
Read/write Time = seek time + latecny + transfer time
```

---
## 3. Disk Addressing
* 디스크는 몇번째 platter? 몇번째 track? 몇번째 sector? 라는 주소를 갖는다.
* 우리는 이 디스크 공간을 사용하기 위해 Logical block에 주소를 매핑할 수 있어야 한다.

### Cylinder-based Mapping
* Cylinder-based Mapping은 말 그대로 기준점을 cylinder로 잡는 것이다. 
* 디스크는 여러개의 Cylinder로 구성되어 있고 각 cylinder마다 여러 개의 Head가 있기 때문에 우리는 Concurrent하게 데이터를 읽고 쓰는 게 가능하다.
* 아래와 그림을 보자.   
![image](https://user-images.githubusercontent.com/61929745/120424136-c0b4e480-c3a6-11eb-8766-aa22588e2f78.png)

---

## 4. Disk Scheduling
* OS는 디스크에 대한 read/write IO 작업을 수행해야 하는데, 이 때 head의 움직임을 최소화하는 것이 효율적이다.
* 따라서, 어떤 IO 작업을 먼저 스케줄링할 것인가에 대한 고민이 생기고 예전에 CPU 스케줄링을 공부했을 때처럼 100% 좋은 방법은 또 없다.

### 1) FCFS 스케줄링
* 먼저 들어온 IO 작업을 먼저 처리하는 방식이다. 
* 아래 그림에서 가로축은 Track의 위치이다.
* FCFS 방식은 그냥 먼저 들어온 놈을 먼저 처리하면 되기 때문에 스케줄링 오버헤드가 없고, 계속 대기해야 하는 녀석도 없다.
* 하지만 그림에서 알 수 있듯이 Head가 계속 와리가리하는 모습을 볼 수 있는데, 성능이 별로 좋지 않다. 
* 따라서 Disk Access 부하가 적은 경우에 적합한 스케줄링이라고 볼 수 있다.   
![image](https://user-images.githubusercontent.com/61929745/120424681-db3b8d80-c3a7-11eb-9fc2-1240e2c6ed40.png)

### 2) SSTF 스케줄링
* 이 방법은 현재 Head에서 가까운 녀석부터 처리하는 방법이다.
* 장점은 throughput이 좋고 평균 응답 시간은 적다.
* 하지만 헤드로부터 멀리 있는 녀석은 그냥 계속 기다려야 하는 문제가 있다.
* 메모리 Throughput이 높아야하거나 일괄처리 시스템에 적합하다.

![image](https://user-images.githubusercontent.com/61929745/120424702-e1ca0500-c3a7-11eb-966f-9fba63992dc9.png)

### 3) SCAN 스케줄링
* 이 스케줄링 기법은 엘리베이터처럼 현재 위치부터 쭉 내려갔다가 쭉 올라가는 방식 OR 쭉 올라갔다가 쭉 내려가는 방식으로 스케줄링한다.
* 장점은 위 SSTF 방법에서 발생하는 starvation 문제를 해결할 수 있고, 응답시간이 작아질 수 있다.
* 하지만 진행방향에 따라서 진행 반대쪽 끝에 있는 녀석의 응답시간은 가장 길어질 수밖에 없고, 이 작업이 중요하다면 손해가 발생한다.   
![image](https://user-images.githubusercontent.com/61929745/120424881-30779f00-c3a8-11eb-953f-f23bd0950b09.png)

### 4) C-SCAN 스케줄링
* 이 방법은 그림처럼 한쪽 방향으로만 스캔을 하는 것이다.
* 일반적인 SCAN 스케줄링에서는 진행 방향 반대편에 있는 녀석이 굉장한 손해를 봤는데, 여기서는 모든 Job이 비슷한 수준의 응답 시간을 유지할 수 있다.   
![image](https://user-images.githubusercontent.com/61929745/120424996-69b00f00-c3a8-11eb-8da2-f864a564ff38.png)

### 5) LOOK / C-LOOK 스케줄링
* LOOK 스케줄링은 이 방법은 SCAN과 같지만 트랙의 양끝을 찍지 않고, 최대/최소 범위 안에서만 움직이는 방식이다.
* C-LOOK은 비슷한 맥락으로 최대/최소 범위 안에서 움직이는데, C-SCAN처럼 한쪽 방향으로만 진행하는 것이다.

```
- SSTF는 흔하게 많이 쓰이는 알고리즘이고
- SCAN, C-SCAN은 disk에 load가 클 때 throughput이 높아진다.
- SSTF, LOOK 방식이 그냥 기본적인 알고리즘이다.
```
---

## 4. Disk Management
* 디스크를 관리할 때는 하나의 디스크를 통째로 쓰지 않고 **Partitioning**해서 사용한다.
* 하나의 디스크는 여러 개의 파티션을 가지고 있고, 각각의 파티션은 논리적으로는 분리된 디스크로 생각할 수 있다.
* 만약 어느 디스크 sector가 박살나면 다른 장소로 sparing된다.

### 1) Swap File Approach
* 기존의 file system에 swap 공간을 확보해놓는다. 하지만 file system에 read, write 등을 해야하기 때문에 오버헤드가 크다.

### 2) Swap Partition Approach
* 디스크 파티셔닝을 할 때 애초에 어느정도 공간을 swap용 공간으로 배정해둔다.
* 위의 Swap file approach보다 효율이 좋지만 파티션해놓은 공간을 너무 크게 잡으면 낭비가 발생할 수도 있다.

---


## 5. Redundant Array of Inexpensive Disk(RAID)
* RAID는 쉽게 말해서 싼 Disk를 여러 개 사용해서 대용량처럼 쓰자라는 개념이다.
* 이 방식은 여러개의 디스크에 데이터를 나눠 놓기 때문에 throughput이 높아질 수 있고
* 여러 디스크에 데이터를 저장해놓기 때문에 하나의 디스크가 망가져도 살아남는 Redundancy를 달성할 수 있다.
* Redundancy를 위한 방법에는 크게 두 가지가 있는데, Mirroring과 parity이다.
* RAID 레벨은 크게 5단계가 있다.

### 1) RAID 0(striped disks)
* 이 방식은 디스크 여러 개에 데이터를 나눠서 저장하는 방식인데, 여러 디스크를 동시에 읽고 쓸 수 있으니까 퍼포먼스는 올라간다.
* 하지만, 여러 디스크에는 서로 다른 데이터만 저장하기 때문에 Redundancy는 없다. 하나 날라가면 끝난다.   
![image](https://user-images.githubusercontent.com/61929745/120426093-674eb480-c3aa-11eb-8081-0c3f4216ee86.png)


### 2) RAID 1(disk mirroring)
* 이 방식은 백업을 할 때처럼 디스크 여러개에 데이터를 똑같이 넣어놓는 것이다.
* 이렇게 하면 일단 read를 할 때도 여러 디스크에 동시 접근해서 읽을 수 있어서 퍼포먼스가 올라가고 Redundancy도 보장할 수 있다.
* 하지만 매 번 데이터를 여러 디스크에 다 write해야하기 때문에 write overhead가 좀 크다.
* 그럼에도 불구하고, 회사 서버같은 중요한 서버같은 경우 Redundancy를 꼭 확보해야 하기 때문에 필요하다.   
![image](https://user-images.githubusercontent.com/61929745/120426106-6d449580-c3aa-11eb-8636-34cee3b15c41.png)


### 3) RAID 3(Striped set with dedicated parity)
* 이 방식은 여러 개 디스크에는 striped한 방식으로 데이터를 그냥 저장해놓고 하나의 Parity disk에 백업용으로 저장을 다 해놓는 것이다.
* 따라서 Parity disk는 bottlneck 현상이 발생할 수 있고, Small writes problem이 발생할 수 있다.

- Small write Problem?
* Small write problem은 아래 그림으로 이해할 수 있다.
* 만약 D0 디스크에 새로운 데이터를 쓰려고 하면 1) 기존에 있던 D0를 읽고(Read), 2) 기존 Parity를 읽고(Read), 3) 새로운 데이터를 D0에 쓰고(Write), 4) Parity 데이터에도 쓰는(Write) 작업이 필요하다.
* 따라서, 한 번의 write를 위해 2번의 read, 2번의 write가 필요해서 오버헤드가 생기는 것이다.   

![image](https://user-images.githubusercontent.com/61929745/120426399-ff4c9e00-c3aa-11eb-9934-eca9755d4a6b.png)

### 4) RAID 5(Striped set with distributed parity)
* 위의 Parity block을 각각의 디스크에 나눠서 저장하는 방식이다.
* RAID 1처럼 어느정도 데이터 안정성을 확보하면서 RAID 0처럼 성능도 좋은 방식을 채택한 것이다.
* 한 번의 disk failure를 커버할 수 있고, disk failure가 발생하면 parity에 저장된 데이터를 replacement하면 된다.   
![image](https://user-images.githubusercontent.com/61929745/120426485-25723e00-c3ab-11eb-97ad-8474b7a07dbc.png)

---

## 6. 니가면서
* Storage 개념에 대해서는 시간이 없어서 중요한 부분만 간략히 정리했는데, 나중에 다시 채워넣어야겠다.
