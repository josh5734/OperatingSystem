## 들어가면서
* 지난 글에서 Synchronization의 필요성과 개념에 대해 정리했다. Critical Section이란 여러 프로세스나 쓰레드들이 공유하는 데이터 영역에 접근하는 것을 의미한다고 했으며, Entry Section과 Exit Section을 정의하였다. 또한 Critical Section을 처리하는 데 있어서 필요한 3가지 요건(Mutual exclusion, Progess, bounded waiting)에 대해 공부했다.
* 이번 글에서는 구체적으로 Critical Section을 처리하려면 어떻게 해야하는가에 대해 Low-level 방법과 High-level에 대해서 공부하려고 한다.

---
## 1. Low-level synchronization primitve(Spinlocks)
### 1) Software-only solution
* 저번 글에서 정리했던 Synchronization의 개념 예제를 떠올려보자. Producer, Consumer가 존재하고 counter 변수를 공유하는 상황이었다.
* Software-only solution은 **Peterson's algorithm**으로 구현한다. 이 방법은 Hardware의 도움을 받지 않고 Software영역에서 Critical Section의 entry와 exit을 처리한다. 아래 예제를 보자.
```
// Process i
repeat
    flag[i] := true;
    turn := j;
    while(flag[j] and turn=j) do no-ops;
        ...
        Critical Section
        ...
    flag[i] = false;
        remainder section
until false;
```
* 위의 Peterson's algorithm은 Critical section을 처리하기 위해 필요한 3가지 요건(Mutual exclusion, Progress, bounded waiting)을 모두 충족시킨다.
* 그렇다면 어떻게 모든 조건을 충족시킬 수 있는지 자세히 생각해보자.
```
flag[i] = true;
// 프로세스 i가 먼저 Critical Section에 접근하기 위해 flag[i]를 true로 설정하여 신호를 보낸다.

turn = j;
// 프로세스 i는 내가 먼저 들어간다고 선언하고 조금 늦게 도착한 j에게 turn을 돌려준다.
// 여기까지 진행된 상태라면 j 입장에서는 flag[j] = true, turn =i일 것이다.
// 그러면 프로세스 i가 j 프로세스로 차례를 넘겨주자마자 아래의 while문을 수행하고 Critical Section에 진입할 수 있다.

while(flag[j] && turn == j);
// Critical section에 들어가기 위해서는 당연히 내 차례여야 한다.
// 따라서 내 차례이거나(turn = i), j가 Critical Section에 진입하고 싶지 않다면(flag[j] = false)
// Spinlock을 빠져나와서 Critical section에 진입할 수 있게 된다.
// 이렇게 turn과 flag 변수를 이용해서 동시 접근을 막는 것이다.
```
* 이렇게 하면 내 순서가 아니면 접근을 할 수 없게 되고 / 내 순서가 아니더라도 남들이 아무도 안 쓰면 쓸 수 있게 되고 / i 입장에서 turn은 j가 바꿔주는 것이기 때문에 critical section을 무한정 쓸 수는 없게 된다. 남이 도와줘야 하기 때문이다.
* 따라서 Peterson algorithm이 software-only solution에서는 동기화문제를 해결하는 방법이 된다.

### 2) Hardware Atomic solution
* Hardware Atomic solution은 위처럼 software 코드만으로는 동기화 문제를 해결하기에 너무 복잡하니까(프로세스가 엄청 많다고 하면 코드가 터지지 않을까?) 고안된 것이다.
* 이 방법은 **atomic instruction**을 통해서 동기화 문제를 해결하고자 하는 것인데, 크게 Test-and-Set instruction과 Swap(or xchg) instruction이 있다.
    - 1) Test-and-Set
    - * Test-and-Set instruction은 공유 데이터로 처음에 false로 초기화된 **var lock**을 사용한다. 동작 방식은 간단한데, lock 변수가 true이면 no-ops 상태여야 하고, lock 변수가 false일 때만 Critical Section에 진입할 수 있게 하는 것이다. 그리고 다시 나갈 때는 lock을 false로 바꾸고 나가면 된다. 하지만 **내가 들어가서 그냥 무한대로 Critical section을 쓸 수 있기 때문에 bounded waiting조건은 충족되지 않는다.**
    - 2) Swap(xchg)
    - * Swap 역시 test-and-set방법과 마찬가지로 bounded waiting 문제는 해결되지 않는다. Swap 역시 마찬가지로 최초에 false로 초기화된 lock 변수를 가지고 있다. 프로세스가 Critical section에 진입하려고 하면 key = true;로 바꾼 후에 Swap(lock, key)를 수행한다. 그렇게 되면 lock이 true가 되고 key는 false가 된 후 critical section에 진입하게 되고, 나갈 때는 lock을 다시 false로 만들어주면 된다.
* Test-and Set Instruction과 Swap instruction을 간단한 코드로 보면 아래와 같다.
```
///////// Test-and-Set
repeat
    while Test-and-Set(lock) do no-ops;
        Critical section
    lock = false;
        remainder section
until false;

//////// Swap 
do{ /* lock is initially false */
    key = true;
    while(key == true) Swap(lock, key);
        critical section
    lock = false;
        remainder section
}
```
### 3) 두 방식의 문제점
* Software-only solution, Hardware atomic instruction은 몇가지 문제점이 존재한다.
1) **Spinning lock이라는 말처럼 프로세스나 쓰레드가 Critical Section에 접근하지 못하는 상황에서는 계속 while loop를 돌고 있기 때문에 비효율적이다. 이거는 꽤 심각한 문제인데, 이렇게 되면 무한루프를 돌고 있는 쓰레드는 다른 쓰레드에게 CPU 할당을 넘겨주지 않아서 스위칭이 잘 일어나지 못하게 되는 것이다.**
2) 그리고 Critical section이 길면 길수록 Spinning lock의 시간이 길어지게 된다.

---
## 2. High-level Synchronization
- 다음에 정리

