### 1. Threads를 구현하는 법
* 이전 글에서 프로세스 모델과 쓰레드 모델의 차이를 설명했다. 프로세스 모델은 각 프로세스 안에 모든 Image와 Context들을 담고 있기 때문에 무거우며, 새로운 프로세스를 만들 때마다 fork()를 수행하기 때문에 모든 내용을 복제하는 메모리 상의 비효율성과 시간적 비효율성을 초래한다고 했다. 이러한 맥락에서 Thread를 사용하는 것이 유리하다고 설명했었다.
* 그렇다면 실제로 Thread는 어떻게 구현할까? - 두 가지 방법이 있다. 우선 아래 그림을 보자.   
![image](https://user-images.githubusercontent.com/61929745/113093304-9b7eeb00-922a-11eb-8fc8-e07aabfd2d6e.png)   
출처: https://awesome-dev.tistory.com/63

#### 1) User-level Threads
* 그림의 오른쪽이 User-level Thread를 표현한 것이다.
* Thread는 라이브러리 모델로 제공되며, 커널 입장에서는 프로세스 안에서 나누어진 Thread에게에 대한 존재를 인식하지 못한다.
* 커널(OS)은 다만 프로세스의 정보만을 담고 있고, 프로세스를 스케줄링의 대상으로 삼는다. 그리고 그 프로세스 안에서만 단순히 Thread에게가 동작하는 것이다.
* 따라서, 한 프로세스 안에 있는 Thread에게들은 **운명 공동체**가 되어버리며, 만약 한 Thread에게에서 Block이 발생하면, 그 프로세스 전체가 Block되는 문제가 생기게 된다.
* 또한, Multiprocessor 머신에서 효율이 더 좋아진다는 보장이 없다.

#### 2) Kernel-level Threading
* 지금 우리가 쓰는 OS는 대부분 Kernel-level Threading을 구현한다.
* User-level Threading과는 다르게 각 Thread가 프로세스에 종속적이지 않고 독립적으로 스케줄링 된다.
* 커널(OS)은 직접 Thread를 스택 영역에서 관리하게 되며, 스케줄러가 Thread 각각의 실행을 관리한다.
* User-level Threading과는 달리 하나의 Thread에서 Block이 일어나도, 그냥 다른 Thread에게 실행권을 넘겨주면 된다.
* Kernel-level Threading방식으로 구현을 하게 되면 여러 Thread가 여러 CPU에서 동시에 돌아갈 수 있게 되며, Blocking System call 이슈를 해결할 수 있다.
---
### 2. Thread Interface - Pthread
* Pthread는 요즘 거의 대부분 Multithreaded application에서 가장 많이 사용하는 라이브러리다. 
* 역사적으로 거슬러 올라가보면, 멀티스레드를 커널에 어떻게 구현하는가에 대한 이슈에 대해 여러 회사와 개발자들이 각각 다른 해결책과 구현법을 내놓았다. 따라서, 이들을 통합하여 제공하는 API라고 이해하면 될 것 같다.

### 3. Pthread의 기본 함수
* Pthread 함수의 기본 함수와 사용방법에 대해서 알아보자.
```c

int pthread_create(pthread_t *th_id, const pthread_attr_t *attr, void *함수명, void *arg);
/**
* th_id: pthread 식별자로 thread가 성공적으로 생성되면 thread 식별값이 주어진다.
* attr: pthread의 속성으로 기본적인 thread 속성을 사용할 경우 Null
* 함수명: pthread로 분기할 함수를 나타낸다. 반환값이 void* 타입이고 매개변수도 void*으로 선언된 함수만 가능하다.
* arg: 분기할 함수로 넘겨줄 인자값이다. 어떤 자료형을 넘겨줄 지 모르기 때문에 void형으로 넘겨주고 상황에 맞게 분기하는 함수 내에서 원래 자료형으로 캐스팅해서 사용한다.
* 리턴 값: 성공적으로 pthread가 생성될 경우 0을 반환한다.
*/

int pthread_join(pthread_t th_id, void** thread_return);
/**
* 특정 pthread가 종료될 때까지 기다리다가 특정 pthread가 종료 시 자원 해제시켜준다.
* 첫번째 인자는 어떤 pthread를 기다릴 지 정하는 식별자이고, 두번째 인자는 pthread의 리턴값으로 포인터로 값을 받아온다.
*/

int pthread_detach(pthread_t th_id);
/**
* th_id 식별자를 가지는 pthread가 부모 pthread로부터 독립한다. 이렇게 독립된 pthread는 따로 pthread_join()없이도 종료 시 자동으로 리소스 해제된다.
*/

void pthread_exit(void* ret_value);
/**
* 현재 실행 중인 thread를 종료시킬 때 사용한다. 보통 pthread_exit가 호출되면 cleanup handler가 호출되어 리소스를 해제한다.
*/

pthread_t pthread_self(void);
/**
* 현재 동작인 pthread 식별자를 리턴한다.
*/
```

### 4. Pthread를 활용해서 간단한 예제 코드를 공부해보자.
### 예제(1)
```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <pthread.h>

/* 최대 쓰레드 개수 */
#define MAX_THREAD_NUM 5

/* thread main function 선언 */
void *thread_function(void *arg);

int main()
{
	int res;
	pthread_t thread_handle[MAX_THREAD_NUM];
	void *thread_result;
	int i;
	
	/* MAX_THREAD_NUM만큼 pthread를 생성한다.*/
	for(i = 0; i < MAX_THREAD_NUM; i++){
		/**
		pthread를 생성하여 생성된 pthread에 대한 handle을 thread_handle 배열에 저장한다.
		pthread의 main_function은 세번째 인자인 thread_function이 되며, 인자로 몇번째로 생성된 pthread인지를 나타내는
		i값을 넘긴다.
		*/
		res = pthread_create(&(thread_handle[i]), NULL, thread_function, (void *)i);
		/* 결과값을 확인하여 Error가 발생하였는지 확인한다. */
		if(res != 0){
			printf("[Main] Thread Creation Failed.\n");
			exit(1);
		} 
	}
	
	/* 메시지 출력 */
	printf("[Main] Waiting for threads to finish..\n");
	
	/* MAX_THREAD_NUM만큼 생성된 모든 pthread가 종료되기를 기다린다. */
	for(i = 0; i < MAX_THREAD_NUM; i++){
		/*
		생성된 pthread가 종료되기를 기다린다.
		pthread 내부에서 pthread_exit가 호출되기 전까지 블록된다.
		pthread_exit의 인자를 pthread_result값으로 전달받는다.
		*/
		
		res = pthread_join(thread_handle[i], &thread_result);
		
		/* 결과값을 확인하여 pthread가 올바로 join되었는지 확인한다. */
		if(res == 0){
			printf("[Main] join thread(%d)\n",i);
		}else{
			printf("[Main] join thread(%d) failed\n", i);
		}
	}
	
	/* 메시지 출력 */
	printf("[Main] All done\n");
	exit(1); 
} 

void *thread_function(void *arg)
{
	/* 인자로 받은 값을 my_number에 저장한다. */
	int my_number = *((int*)(&arg));
	int rand_num;

	/* 몇번째 pthread가 실행중인지 메시지를 출력한다. */
	printf("[thread(%d)] is running\n", my_number);
	
	/* 1부터 5 사이의 임의의 값을 생성한다. */
	rand_num = 1 + (int)(5.0*rand()/(RAND_MAX+1.0));
	
	/* 생성된 임의의 값만큼 sleep한다. */
	sleep(rand_num);
	
	/* sleep이 끝났음을 메시지로 출력한다 */
	printf("[thread(%d)] job done\n", my_number);
	
	/* thread 작업이 종료되었음을 알린다. */
	pthread_exit(NULL);
}
```
[결과]   
<img src = "https://user-images.githubusercontent.com/61929745/113096873-fe738080-9230-11eb-9825-63a4a2a4484f.png" width = 800 />


### 마치면서
* Thread의 필요성에 대해 이전 글에서 공부했고, 오늘은 Thread를 어떻게 구현할 것인가에 대한 물음에 Kernel-level로 구현하는 것에 집중했다.
* 그리고 Thread를 구현하는 대표적이고 보편적인 Pthread 라이브러리에 대해 간단히 알아보고 코드를 리뷰했다. C언어가 아직 익숙하지 않기 때문에 코드 예제를 보면서 공부해보고 과제를 하면서도 공부해봐야겠다.
