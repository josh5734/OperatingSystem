## 0. 들어가면서
* 지난 글에서 메모리 관리 기법 중 paging 기법에 대해 공부했다.
* paging 기법은 논리적 메모리를 page 단위로 쪼개고, 물리적 메모리를 frame 단위로 쪼개서 이를 대응하는 방식으로 noncontiguous했다.
* 하지만 pagigng기법에서는 Memory access overhead 문제와 Large page table을 관리하는 memory issue가 있었고, 이를 해결하기 위해 각각 TLB와 Multi-level paging, Inverted-page table 등에 대해서 공부했다
* 이번 글에서는 Segmentation이라는 방법을 통해 메모리를 관리하는 기법에 대해 알아보고, paging 기법과 segmentation 기법을 비교해보고 섞어서 사용하는 방식에 대해 공부하고자 한다.

---
## 1. Segmentation 기법의 필요성
```
- 프로세스는 이미지로 구성되어 있고, 이미지는 각 content에 따라 다른 특징을 가지고 있다. 
- 이러한 content를 특징에 따라서 모아둔 것을 'segment'라고 하며 프로세스는 segment들로 이루어진 집합이라고 재정의할 수 있다.
- 이전에 배운 paging기법에서는 lineaer address를 page 단위로 쪼갠 뒤 frame에 할당하는 방식으로써, segment 개념이 존재하지 않았다.
- 그래서 우리는 이제 **프로세스의 이미지 영역들을 page가 아닌 segment 단위로 쪼개서 물리적 메모리에 저장하고자 하는 것이다.**
```
---
## 2. Example of Segmentation
* 본격적으로 세그멘테이션을 통한 메모리 관리 기법을 들여다보기 전에, 예제 그림을 하나를 보면서 대충 이해를 해보면 좋겠다.   
![image](https://user-images.githubusercontent.com/61929745/117755884-0f63d880-b258-11eb-80c3-0cb4e4a76d88.png)   

```
- 왼쪽 그림을 보면 하나의 프로세스는 논리적 주소 공간에 여러 개의 segment를 가진다.
- 세그먼트들은 페이징 기법에서와 비슷하게 **segment table**을 통해 물리적 메모리 영역의 어느 위치에 저장되는지 확인할 수 있다.

- 오른쪽 그림을 보면 두 개의 프로세스가 존재한다.
- 두 개의 프로세스는 "editor"라는 세그먼트를 공유하는데, 그렇게 되면 이 세그먼트를 물리적 메모리에 하나만 두고 이를 공유해서 사용함으로써 메모리 관리의 이점을 얻을 수 있게 된다.
```
---

## 3. Segmentation Architecture
* Segmentation을 이용한 메모리 관리는 Paging 기법과 유사하다. 아래 그림을 보자.   
![image](https://user-images.githubusercontent.com/61929745/117756174-a29d0e00-b258-11eb-8b9f-d51a706a322b.png)

```
- 프로세스의 논리적인 주소는 이제 <# of Segment, offset>으로 표현된다. 페이징 기법과 거의 똑같다.
- Segment table은 각 segment가 저장된 물리적 메모리의 주소를 표현하기 위해 "Base", "Limit" 두 가지 변수를 사용한다.
- Base는 segment가 저장된 물리적 메모리의 시작 주소를 의미하며, Limit는 segment의 길이를 나타낸다. 
- 따라서 물리적 영역에서 세그먼트가 저장된 공간은 [Base, Base+Limit]일 것이다.
- 한편, segment table의 위치를 저장하기 위해서는 Segment-table base register(STBR)이 존재하고, 한 프로그램이 가지는 segment의 수를 저장하기 위해 Segment-table length register(STLR)이 존재한다.
- TODO: 그림에서 d < limit의 의미가 뭐지?
```

## 4. Segmentation의 특징과 Paging과의 비교
### 1) Protection, Sharing
```
- 페이징에서는 code + data + stack 영역이 있을 때 이를 일정한 크기로 나누기 때문에 여러 영역이 섞이는 문제가 발생할 수 있었다. 
- 하지만 세그멘테이션은 r, w, x 비트들을 테이블에 추가할 수 있고, 이를 통해 Protection의 이점을 살릴 수 있다. 
```
### 2) Sharing
```
- 페이징에서는 code 영역을 나눈다해도 다른 영역이 포함될 확률이 매우 높다. 하지만 세그멘테이션은 정확히 code 영역만 나누기 때문에 더 효율적으로 공유를 수행할 수 있다.
```

### 3) External Fragmentation
```
- Paging에서는 논리적 영역의 메모리를 같은 크기의 page로 쪼갰기 때문에 internal fragmentation이 발생했다. 
- 세그멘테이션 기법에서도 유사한 문제가 발생한다. 기본적으로 content의 특징에 따라 segment로 나뉘는 것이기 때문에 세그먼트의 크기 또한 다양할 수밖에 없다. 
- 이로 인해 다양한 크기의 hole이 발생하므로 external fragmentation 이슈가 남게 되는 것이다.
```


---
## 5. Segmentation with Paging
* 세그멘테이션은 보호와 공유에서 효율적이고, 페이징은 external fragmentation문제를 해결할 수 있다.
* 두 가지 기법의 장단점을 생각하다 보니, "세그먼트를 페이징 기법으로 나누는 방식은 어떨까?"에 대한 방법이 등장했다.
### 1) Concept
```
- 이 방법의 핵심은 Segments become "pageable" 개념이다.
- 하나의 세그먼트를 내부적으로는 여러 개의 page로 나누고, 이 page를 물리적 메모리에 매핑하는 것이다.
- 이렇게 하면 segment의 특징을 보존하면서 sharing, protection의 이점을 살릴 수 있고,
- segment 단위가 아닌 조금 더 작은 page 단위로 메모리를 다룸으로써 external fragmentation을 줄일 수 있는 것이다.
```
### 2) Implemetation   
![image](https://user-images.githubusercontent.com/61929745/117758447-075a6780-b25d-11eb-8ebb-1592cdab0708.png)

```
- 개별적인 segment는 물리적 주소의 어느 공간에 저장되어 있는지 알기 위해 세 가지 정보가 필요하다.
- 1) 몇 번째 segment인가? 2) 이 세그먼트는 어느 페이지에 속했는가? 3) 이 페이지의 offset은?

- 풀어서 이야기하면 segment의 단위가 page보다 크기 때문에 일단 몇 번째 segment인지를 찾고
- 그러면 그 segment 내에서 page 단위로 쪼개졌을텐데, 지금 저장하고자 하는 메모리가 어느 page인지 찾고
- 그 page 내에서도 offset을 구해서 진짜 물리적 메모리에 저장하겠다는 것이다.
```

![image](https://user-images.githubusercontent.com/61929745/117758414-f6a9f180-b25c-11eb-90cc-b82931549efd.png)

```
- 위 그림에서 segment table을 보면 segment table의 인덱스는 segment number가 된다.
- segment number를 얻어서 segment table의 entry를 얻으면, 그 안에 page table에 대한 정보가 들어있다.
- page table의 index는 마찬가지로 page number가 된다.
- 해당 페이지의 entry를 보면 페이지가 어느 물리적 메모리에 매핑됐는지에 대한 frame number를 얻을 수 있다.
```

### 3) Pros and Cons
* Segmentation with paging기법은 메모리 공간의 fragmentation 문제를 줄이면서도 세그먼트의 특징을 살려서 bit 정보를 통한 Protection과 Sharing의 이점이 있다.
* 하지만, 위에서 본 것처럼 논리적 메모리가 물리적 메모리의 어느 부분에 매핑됐는지 찾아가기 위해서는 segment table, page table에 두 번 접근해야 하는 성능 이슈가 남는다.
---

## 6. 나가면서
* 이번에는 Segmentation 기법을 통한 메모리 관리 기법에 대해 공부했다.
* 이 방법의 핵심은 
```
* 1) bit 정보를 통해 Read, Write, Executable 등의 권한을 명시함으로써 Protection 기능을 수행할 수 있고,
* 2) 물리적 메모리의 Segment를 공유함으로써 Sharing의 이점이 있지만
* 3) Segment 단위로 저장하기 때문에 external fragmentation 이슈가 생기는 것이다.
```
* 따라서 이 문제를 해결하기 위해 Paging 기법을 섞어서 사용하는 방법에 대해 공부했다.
* 이 방법은 메모리 효율은 좋아지지만 Access 관점에서 overhead가 커지는 단점이 존재하긴 했다.




