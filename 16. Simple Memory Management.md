## 0. 들어가면서
* 이제 실제로 Memory Managemnt를 하는 방법들에 대해서 공부하려고 한다.
* 단, 지금부터 소개하는 방법은 기본적으로 **Process의 크기만큼 Main Memory에 공간이 있어야 한다는 것을 가정한다.**


## 1. Fixed Partitioning
```
- 이 방법은 메인 메모리를 일정한 사이즈의 Partition으로 나누고, Partition의 size보다 작은 프로세스를 할당할 수 있도록 하는 것이다.
- 그리고 이전에 Swapping 개념을 배운 것을 토대로, 모든 Partition이 다 차있다면 OS는 swapping을 통해 기존 프로세스를 이동시키고 배치하는 등의 작업을 진행한다.
- 이 방법에서 가장 큰 문제점은 하나의 프로세스가 하나의 Partition을 모두 차지하기 때문에, Internal fragmentation이 발생할 수 있다는 점이다.
- 한편 만약 Partition의 크기를 다르게 쪼갠다고 하더라도, Internal fragmentation이 적어질 수는 있지만 이 문제를 완벽히 해결하기는 어렵다.

- Fixed Partitioning을 통해 메모리를 관리하는 구체적인 알고리즘은 여러가지가 있을 수 있다.
1) Use of multiple queues
- 각각의 프로세스를 자신보다는 크지만 가장 작은 partition에 넣기 위해 각각의 partition에 대한 queue를 만들어두는 것이다.
- internal fragmentation을 감소시킬 수는 있지만, 특정 partition에만 프로세스가 몰리는 현상이 발생할 수도 있다.
2) Use of a single queue
- 하나의 큐에 프로세스를 저장하고, 그 프로세스를 수용할 수 있는 가장 작은 partition에 할당하는 방법이다.
- 이 방법에서는 큰 공간에도 작은 프로세스를 할당할 가능성이 생겨서 internal fragmentation이 생길 수는 있지만,
- 프로세스를 무작정 대기큐에서 기다리게 하지 않고 partition에 할당함으로써 concurrent하게 작업을 돌릴 수는 있는 장점이 있다.
```
---
## 2. Dynamic Partitioning
```
- 이 방법에서는 각 Partition의 길이가 유동적이다.
- 각 프로세스는 딱 자신의 크기만큼 partition size를 할당받기 때문에 internal fragmentation이 없다.
- Dynamic Partitioning에서 Placement Algorithm에는 여러가지 방법이 있다.
1) Best-fit: Process를 담을 수 있는 가장 작은 크기의 hole을 선택하기
2) First-fit: 처음 시작점부터 스캔하면서 자신을 담을 수 있는 hole 선택하기
3) Next-fit: 마지막으로 할당된 hole부터 스캔하면서 자신을 담을 수 있는 hole 선택하기
4) Worst-fit: 가장 큰 사이즈의 hole을 선택하게 되면, 남은 hole의 크기도 클 것을 예상해서 다른 process가 또 사용할 수 있게 하는 방법
```
* 아래 그림을 참고하자.   
![image](https://user-images.githubusercontent.com/61929745/117270606-589cdc80-ae94-11eb-9243-17f5d9c670c3.png)

```
- 하지만 Dynamic partitioning은 프로세스를 할당하다보면 연속적인 메인 메모리 공간에서 이미 할당된 공간 사이에 비어 있는 "hole"이 발생하고 
- 이것이 External fragmentation이라는 비효율성을 낳게 될 수 있다.   
```
* 아래 그림을 보자.   
![image](https://user-images.githubusercontent.com/61929745/117269569-5b4b0200-ae93-11eb-82b1-ef43af8ade4b.png)

* 위 그림에서 (f)에서 (g)로 갈 때 P1이 swapped out되고, P2가 배치된다. 결국 (h) 상황에 이르렀을 때, 두 개의 96K 메모리와 64K 메모리가 놀게 된다.
---

## 3. Compaction & Overlays
* 또 다른 방법을 소개하기 전에 두 가지 개념을 짚고 넘어가자.
### 1. Compaction
- Compation이란 external fragmentation 문제를 해결하기 위해 할당된 프로그램들을 차곡차곡 밀고 옮겨서(relocation) 공간을 효율적으로 확보하는 것이다.
- 이러한 dynamic relocation은 execution time에 일어나는데, 주의해야 할 점은 I/O Operation 같은 작업 중인 Process는 작업이 끝나고 메모리 주소를 옮겨줘야 한다.
- 아래 그림을 통해 보면 직관적으로 이해될 것 같다.   
![image](https://user-images.githubusercontent.com/61929745/117271428-23dd5500-ae95-11eb-8147-14cf7fce7d96.png)

### 2. Overlays
- Overlays는 메인 메모리의 공간이 부족할 때 큰 프로세스를 돌리는 방법이다.
- 만약 어떤 거대한 프로그램 P가 함수 A, B를 호출하고 / 함수 B는 또다시 C, D함수를 호출하는 상황을 생각해보자.
- 그런데 이 모든 프로세스를 한 번에 메모리에 올릴 수 없을 때는 **Call graph**에 따라 적절한 순서(의존성 있는)로 메모리에 loading하는 것이다.
- 마찬가지로 그림을 통해 보면 직관적으로 이해될 것 같다.   
![image](https://user-images.githubusercontent.com/61929745/117271467-2e97ea00-ae95-11eb-9c5e-2ad51609e9c1.png)

---

## 4. Buddy System
```
- Buddy System은 fixed, dynamic partitioning 기법의 fragmentation 발생 이슈를 보완하기 위한 개념이다.
- 이 방법은 실제로 Linux OS에서도 사용하는 것으로, 꽤 중요한 개념이다.
- 절차는 크게 어렵지 않게 이해할 수 있는데, 아래 과정을 따른다.
1) 메인 메모리는 항상 2^N size로 할당한다.
2) 사용할 수 있는 가장 큰 메모리부터 시작해서 Binary로 절반씩 쪼개나가면서 아래 조건을 만족시키는 공간을 찾는다.
3) 만약 프로세스 메모리 크기가 K라고 하면, 2^(U-1) <= K <= 2^U 를 만족시키는 U를 찾고, 2^U 만큼의 공간에 프로세스를 할당한다.
- 예를 들어, 프로세스 크기가 1000B이면, 512B < 1000B < 1024B이기 때문에 1024B 사이즈의 메모리에 할당하는 것이다. 
4) 프로세스가 종료되고, 만약 같은 Parent를 갖는 Buddy 공간이 비어있다면 Merge한다.
```
* 아래 그림을 보자.   
![image](https://user-images.githubusercontent.com/61929745/117272377-18d6f480-ae96-11eb-9a79-8df58d6cb7e1.png)   

* 맨 처음에는 1M만큼의 전체 메모리가 존재하고, 100K의 프로세스가 요청될 때 메모리를 쪼개가면서 128K의 공간을 할당한다.
* 이런 과정을 반복하다가 어떤 Process가 Release되면 자신의 Buddy(같은 부모로부터 Split된 녀석)을 찾고, Buddy가 비어있다면 Merge한다.

---

## 5. 나가면서
* 몇 가지 간단한 메모리 관리 기법과 Fragmentation, compaction, overlay 개념에 대해 공부했다.
* 다음 글에서 다른 메모리 관리 기법에 대해 이어서 정리하고자 한다.
